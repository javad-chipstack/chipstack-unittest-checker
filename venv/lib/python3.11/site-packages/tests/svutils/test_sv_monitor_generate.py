from chipstack_common.svutils.sv_monitor_generate import (
    generate_submodule_model,
    convert_module_to_monitor,
    generate_module_declaration,
    generate_module_declaration_no_ports,
    add_type_aliases_to_module,
    remove_module_declaration_and_endmodule,
)
from chipstack_common.svutils.sv_parse_types import (
    Module,
    ModulePort,
    ModuleParameter,
    Clock,
    Reset,
    ModuleInterface,
)


def test_remove_module_declaration_and_endmodule():
    code = """
    module test_module
    #(
        parameter logic C = 2
    )
    (
        input logic clk,
        input logic rst,
        input logic[3:0] A[2:0],
        output logic [5:0] B
    );
    endmodule

    always @(posedge clk) disable iff (rst) begin
    // module A;
        A = 1;
        B = 2;
        C = 3; 
    end

    module test_module2
    #(
        parameter logic C = 2
    )
    (
        input logic clk,
        input logic rst,
        input logic[3:0] A[2:0],
        output logic [5:0] B
    );
    endmodule
    """

    result = remove_module_declaration_and_endmodule(code)
    assert (
        result
        == """
    

    always @(posedge clk) disable iff (rst) begin
    // module A;
        A = 1;
        B = 2;
        C = 3; 
    end

    
    """
    )


def test_generate_submodule_module_all_signals_present():
    module = Module(
        name="test_module",
        input_ports=[ModulePort(name="A", type="logic")],
        output_ports=[ModulePort(name="B", type="logic")],
        inout_ports=[],
        clock_ports=[Clock(name="clk", type="logic")],
        reset_ports=[Reset(name="rst", type="logic")],
        parameters=[
            ModuleParameter(name="C", type="logic", kind="parameter", value="2")
        ],
    )
    code = """
    always @(posedge clk) disable iff (rst) begin
        A = 1;
        B = 2;
        C = 3; 
    end
    """

    submodule = generate_submodule_model(
        name="test_submodule", code=code, dut_top_module=module
    )

    assert submodule.input_ports == module.input_ports
    assert submodule.output_ports == module.output_ports
    assert submodule.inout_ports == []
    assert submodule.clock_ports == module.clock_ports
    assert submodule.reset_ports == module.reset_ports
    assert submodule.parameters == module.parameters


def test_generate_submodule_module_some_ports_present():
    module = Module(
        name="test_module",
        input_ports=[ModulePort(name="A", type="logic")],
        output_ports=[ModulePort(name="B", type="logic")],
        inout_ports=[],
        clock_ports=[],
        reset_ports=[],
        parameters=[
            ModuleParameter(name="C", type="logic", kind="parameter", value="2")
        ],
    )
    code = """
    always @(posedge clk) begin
        A = 1;
        C = 3; 
    end
    """

    submodule = generate_submodule_model(
        name="test_submodule", code=code, dut_top_module=module
    )

    assert submodule.input_ports == module.input_ports
    assert submodule.output_ports == []
    assert submodule.inout_ports == []
    assert submodule.clock_ports == []
    assert submodule.reset_ports == []
    assert submodule.parameters == module.parameters


def test_generate_submodule_module_no_parameters_preset():
    # always add all parameters to submodule
    module = Module(
        name="test_module",
        input_ports=[ModulePort(name="A", type="logic")],
        output_ports=[ModulePort(name="B", type="logic")],
        inout_ports=[],
        clock_ports=[],
        reset_ports=[],
        parameters=[
            ModuleParameter(name="C", type="logic", kind="parameter", value="2")
        ],
    )
    code = """
    always @(posedge clk) begin
        A = 1;
        B = 2;
    end
    """

    submodule = generate_submodule_model(
        name="test_submodule", code=code, dut_top_module=module
    )

    assert submodule.input_ports == module.input_ports
    assert submodule.output_ports == module.output_ports
    assert submodule.inout_ports == []
    assert submodule.clock_ports == []
    assert submodule.reset_ports == []
    assert submodule.parameters == module.parameters


def test_convert_monitor_to_module():
    input_interface_ports = [ModulePort(name="D", type="logic")]
    output_interface_ports = [ModulePort(name="E", type="logic")]
    module = Module(
        name="test_module",
        input_ports=[ModulePort(name="A", type="logic")],
        output_ports=[ModulePort(name="B", type="logic")],
        inout_ports=[],
        clock_ports=[Clock(name="clk", type="logic")],
        reset_ports=[Reset(name="rst", type="logic")],
        parameters=[
            ModuleParameter(name="C", type="logic", kind="parameter", value="2")
        ],
        interfaces=[
            ModuleInterface(
                name="interface",
                input_ports=input_interface_ports,
                output_ports=output_interface_ports,
                instance="",
                modport="",
            )
        ],
    )

    monitor = convert_module_to_monitor(module, monitor_name="test_monitor")

    assert monitor.name == "test_monitor"
    assert monitor.input_ports == module.input_ports + module.output_ports
    assert monitor.output_ports == []
    assert monitor.inout_ports == []
    assert monitor.clock_ports == module.clock_ports
    assert monitor.reset_ports == module.reset_ports
    assert monitor.parameters == module.parameters
    assert monitor.interfaces == [
        ModuleInterface(
            name="interface",
            input_ports=input_interface_ports + output_interface_ports,
            output_ports=[],
            instance="",
            modport="",
        )
    ]
    assert monitor.instance == ""


def test_module_to_monitor_reg_wire_types():
    input_interface_ports = [ModulePort(name="D", type="wire")]
    output_interface_ports = [ModulePort(name="E", type="logic")]
    module = Module(
        name="test_module",
        input_ports=[ModulePort(name="A", type="reg [5:0]")],
        output_ports=[ModulePort(name="B", type="logic")],
        inout_ports=[],
        clock_ports=[Clock(name="clk", type="logic")],
        reset_ports=[Reset(name="rst", type="reg")],
        parameters=[
            ModuleParameter(name="C", type="logic", kind="parameter", value="2")
        ],
        interfaces=[
            ModuleInterface(
                name="interface",
                input_ports=input_interface_ports,
                output_ports=output_interface_ports,
                instance="",
                modport="",
            )
        ],
    )

    monitor = convert_module_to_monitor(module, monitor_name="test_monitor")
    print(monitor)
    assert monitor.name == "test_monitor"
    assert monitor.input_ports == [
        ModulePort(name=port.name, type="logic [5:0]") for port in module.input_ports
    ] + [ModulePort(name=port.name, type="logic") for port in module.output_ports]
    assert monitor.output_ports == []
    assert monitor.inout_ports == []
    assert monitor.clock_ports == [
        Clock(name=clock.name, type="logic") for clock in module.clock_ports
    ]
    assert monitor.reset_ports == [
        Reset(name=reset.name, type="logic") for reset in module.reset_ports
    ]
    assert monitor.parameters == module.parameters
    assert monitor.interfaces == [
        ModuleInterface(
            name="interface",
            input_ports=[
                ModulePort(name=port.name, type="logic")
                for port in input_interface_ports
            ]
            + [
                ModulePort(name=port.name, type="logic")
                for port in output_interface_ports
            ],
            output_ports=[],
            instance="",
            modport="",
        )
    ]
    assert monitor.instance == ""


def test_generate_module_declaration():

    module = Module(
        name="test_module",
        input_ports=[
            ModulePort(name="A", type="logic[3:0]$[2:0]")
        ],  # unpacked signal type in slang
        output_ports=[ModulePort(name="B", type="logic [5:0]")],
        inout_ports=[],
        clock_ports=[Clock(name="clk", type="logic")],
        reset_ports=[Reset(name="rst", type="logic")],
        parameters=[
            ModuleParameter(name="C", type="logic", kind="parameter", value="2")
        ],
    )

    module_declaration = generate_module_declaration(module)
    assert (
        module_declaration
        == """module test_module
    #(
        parameter logic C = 2
    )
    (
        input logic clk,
        input logic rst,
        input logic[3:0] A[2:0],
        output logic [5:0] B
    );
"""
    )


def test_generate_module_declaration_no_ports():

    module = Module(
        name="test_module",
        input_ports=[
            ModulePort(name="A", type="logic[3:0]$[2:0]")
        ],  # unpacked signal type in slang
        output_ports=[ModulePort(name="B", type="logic [5:0]")],
        inout_ports=[],
        clock_ports=[Clock(name="clk", type="logic")],
        reset_ports=[Reset(name="rst", type="logic")],
        parameters=[
            ModuleParameter(name="C", type="logic", kind="parameter", value="2")
        ],
    )

    module_declaration = generate_module_declaration_no_ports(module)
    assert (
        module_declaration
        == """module test_module
    #(
        parameter logic C = 2
    ) ();

    logic clk;
    logic rst;
    logic[3:0] A[2:0];
    logic [5:0] B;

"""
    )


def test_add_type_aliases_to_module():
    dut_parsed_model = {
        "name": "tt_ex",
        "parameters": [
            {
                "name": "INCL_VEC",
                "type": "logic signed[31:0]",
                "kind": "IntegerLiteral",
                "value": "0",
            },
            {
                "name": "VLEN",
                "type": "logic signed[31:0]",
                "kind": "IntegerLiteral",
                "value": "128",
            },
            {
                "name": "ADDRWIDTH",
                "type": "logic signed[31:0]",
                "kind": "IntegerLiteral",
                "value": "40",
            },
            {
                "name": "ST_DATA_WIDTH_BITS",
                "type": "logic signed[31:0]",
                "kind": "IntegerLiteral",
                "value": "128",
            },
            {
                "name": "LQ_DEPTH_LOG2",
                "type": "logic signed[31:0]",
                "kind": "Parameter",
                "value": "3",
            },
            {
                "name": "XLEN",
                "type": "logic signed[31:0]",
                "kind": "Parameter",
                "value": "32",
            },
        ],
        "input_ports": [
            {"name": "i_if_ex_deco", "type": "logic[36:0]"},
            {"name": "i_if_ex_predicted", "type": "logic"},
            {"name": "i_if_ex_nextinstr", "type": "logic"},
            {"name": "i_ex_vec_csr", "type": "csr_to_vec"},
            {"name": "i_id_ex_lqid", "type": "logic[2:0]"},
            {"name": "i_id_type", "type": "logic[4:0]"},
            {"name": "i_id_rf_wr_flag", "type": "logic"},
            {"name": "i_id_rf_wraddr", "type": "logic[4:0]"},
            {"name": "i_id_fp_rf_wr_flag", "type": "logic"},
            {"name": "i_id_fp_rf_wraddr", "type": "logic[4:0]"},
            {"name": "i_id_immed_op", "type": "logic[31:0]"},
            {"name": "i_id_ex_rts", "type": "logic"},
            {"name": "i_id_ex_vecldst", "type": "logic"},
            {"name": "i_id_ex_Zb_instr", "type": "logic[4:0]"},
            {"name": "i_id_ex_units_rts", "type": "logic"},
            {"name": "i_id_ex_pc", "type": "logic[31:0]"},
            {"name": "i_id_ex_instrn", "type": "logic[31:0]"},
            {"name": "i_id_ex_vecldst_autogen", "type": "vecldst_autogen_s"},
            {"name": "i_id_ex_instdisp", "type": "logic"},
            {"name": "i_id_ex_last", "type": "logic"},
            {"name": "i_rf_p0_reg", "type": "logic[63:0]"},
            {"name": "i_rf_p1_reg", "type": "logic[63:0]"},
            {"name": "i_fp_rf_p3_reg", "type": "logic[31:0]"},
            {"name": "i_vmask_rddata", "type": "logic[127:0]"},
            {"name": "i_vs2_rddata", "type": "logic[127:0]"},
            {"name": "i_vs3_rddata", "type": "logic[127:0]"},
            {"name": "i_mem_ex_rtr", "type": "logic"},
            {"name": "i_exc_fp_ex_update", "type": "csr_fp_exc"},
            {"name": "i_exc_vfp_update", "type": "csr_fp_exc"},
            {"name": "i_sat_csr", "type": "logic"},
        ],
        "inout_ports": [],
        "output_ports": [
            {"name": "o_ex_bp_fifo_pop", "type": "logic"},
            {"name": "o_ex_is_some_branch", "type": "logic"},
            {"name": "o_ex_branch_taken", "type": "logic"},
            {"name": "o_ex_id_rtr", "type": "logic"},
            {"name": "o_ex_last", "type": "logic"},
            {"name": "o_ex_dst_vld_1c", "type": "logic"},
            {"name": "o_ex_dst_lqid_1c", "type": "logic[2:0]"},
            {"name": "o_ex_fwd_data_1c", "type": "logic[31:0]"},
            {"name": "o_ex_dst_vld_2c", "type": "logic"},
            {"name": "o_ex_dst_lqid_2c", "type": "logic[2:0]"},
            {"name": "o_ex_fwd_data_2c", "type": "logic[31:0]"},
            {"name": "o_ex_bp_mispredict", "type": "logic"},
            {"name": "o_ex_bp_mispredict_not_br", "type": "logic"},
            {"name": "o_ex_bp_pc", "type": "logic[31:0]"},
            {"name": "o_ex_id_csr", "type": "csr_to_id"},
            {"name": "o_ex_vec_csr", "type": "csr_to_vec"},
            {"name": "o_ex_mem_lqvld_1c", "type": "logic"},
            {"name": "o_ex_mem_lqdata_1c", "type": "logic[31:0]"},
            {"name": "o_ex_mem_lqid_1c", "type": "logic[2:0]"},
            {"name": "o_ex_mem_lqvld_2c", "type": "logic"},
            {"name": "o_ex_mem_lqdata_2c", "type": "logic[31:0]"},
            {"name": "o_ex_mem_lqid_2c", "type": "logic[2:0]"},
            {"name": "o_ex_mem_payload", "type": "mem_skidbuf_s"},
            {"name": "o_ex_mem_vld", "type": "logic"},
        ],
        "interfaces": [],
        "clock_ports": [{"name": "i_clk", "type": "logic"}],
        "reset_ports": [
            {"name": "i_reset_n", "type": "logic"},
            {"name": "i_reset_pc", "type": "logic[31:0]"},
        ],
        "instance": "",
        "type_aliases": {
            "csr_to_vec": "struct packed{logic[2:0] v_vsew;logic[2:0] v_lmul;logic[1:0] v_vxrm;logic[8:0] v_vl;}s$1",
            "vecldst_autogen_s": "struct packed{logic load;logic store;logic[4:0] dest_reg;logic ldst_ustride;logic ldst_strided;logic ldst_index;logic ldst_mask;logic ldst_whole_register;logic[5:0] ldst_iter_cnt;logic[5:0] ldst_iterations;logic[7:0] ldst_dest_incr;logic[7:0] ldst_index_incr;}s$2",
            "mem_skidbuf_s": "struct packed{logic[2:0] mem_lqid;logic[2:0] mem_sz;logic[31:0] mem_alu_result;logic[255:0] mem_store_data;logic mem_tx_valid;logic mem_lq_valid;logic mem_load;logic mem_store;logic mem_amo;logic[4:0] mem_amotype;logic mem_fence;logic mem_ordered;logic[39:0] mem_addr;logic[7:0] mem_byten;logic vecldst_vld;logic vecldst_128;logic[4:0] vecldst_idx;logic vecldst_idx_last;logic[31:0] vecldst_byte_mask;}s$3",
            "bitmanip_instrn_e": "enum{BIT_NONE=5'd0,BIT_CLZ=5'd1,BIT_CTZ=5'd2,BIT_CPOP=5'd3,BIT_MIN=5'd4,BIT_MINU=5'd5,BIT_MAX=5'd6,BIT_MAXU=5'd7,BIT_SEXT_B=5'd8,BIT_SEXT_H=5'd9,BIT_PACK=5'd10,BIT_ANDN=5'd11,BIT_ORN=5'd12,BIT_XNOR=5'd13,BIT_ROL=5'd14,BIT_ROR=5'd15,BIT_RORI=5'd16,BIT_GREVI=5'd17,BIT_GORCI=5'd18,BIT_SH1ADD=5'd19,BIT_SH2ADD=5'd20,BIT_SH3ADD=5'd21,BIT_RSVD22=5'd22,BIT_RSVD23=5'd23,BIT_RSVD24=5'd24,BIT_RSVD25=5'd25,BIT_RSVD26=5'd26,BIT_RSVD27=5'd27,BIT_RSVD28=5'd28,BIT_RSVD29=5'd29,BIT_RSVD30=5'd30,BIT_RSVD31=5'd31}e$1",
            "csr_fp_exc": "struct packed{logic fpNV;logic fpDZ;logic fpOF;logic fpUF;logic fpNX;}s$4",
            "csr_to_id": "struct packed{logic[31:0] vgsrc;logic[2:0] v_vsew;logic[2:0] v_lmul;logic[7:0] v_vlmax;logic[8:0] v_vl;}s$5",
        },
        "internal_signals": [
            "ex_vecldst_autogen",
            "ex_mem_payload_fn",
        ],
    }
    codeblocks = [
        """
module test_BranchTaken
    #(
        parameter logic signed[31:0] INCL_VEC = 0,
        parameter logic signed[31:0] VLEN = 128,
        parameter logic signed[31:0] ADDRWIDTH = 40,
        parameter logic signed[31:0] ST_DATA_WIDTH_BITS = 128,
        parameter logic signed[31:0] LQ_DEPTH_LOG2 = 3,
        parameter logic signed[31:0] XLEN = 32
    )
    (
        input logic i_clk,
        output logic[4:0] i_id_type,
        output logic[31:0] i_id_immed_op,
        output logic[31:0] i_id_ex_pc,
        input logic o_ex_branch_taken,
        input logic[31:0] o_ex_bp_pc
    );
    task automatic test_BranchTaken;
      bit expected_branch_taken = 1'b1;
      bit observed_branch_taken;
      logic [ADDRWIDTH-1:0] expected_branch_target_address = 'hDEADBEEF; // Example target address
      logic [ADDRWIDTH-1:0] observed_branch_target_address;
      begin
        // Set initial conditions for a branch taken scenario
        i_id_type = `BRANCH; // Assuming `BRANCH` is the correct encoding for a branch instruction
        i_id_ex_pc = 'hDEADBE00; // Example current PC address
        i_id_immed_op = 'hEEF; // Immediate value to add to PC for branch target address
        // Assuming active edge of the clock is posedge for this design
        @(posedge i_clk);
        observed_branch_taken = o_ex_branch_taken;
        observed_branch_target_address = o_ex_bp_pc;
        // Compare expected output with observed output and print pass or fail
        if (expected_branch_taken == observed_branch_taken && expected_branch_target_address == observed_branch_target_address) begin
          $display("PASSED: test_BranchTaken");
        end 
        else begin
          $display("FAILED: test_BranchTaken");
        end
      end
    endtask
    endmodule
""",
        """
module test_LoadOperation
    #(
        parameter logic signed[31:0] INCL_VEC = 0,
        parameter logic signed[31:0] VLEN = 128,
        parameter logic signed[31:0] ADDRWIDTH = 40,
        parameter logic signed[31:0] ST_DATA_WIDTH_BITS = 128,
        parameter logic signed[31:0] LQ_DEPTH_LOG2 = 3,
        parameter logic signed[31:0] XLEN = 32
    )
    (
        input logic i_clk,
        output logic[4:0] i_id_type,
        output logic[63:0] i_rf_p0_reg,
        input logic o_ex_mem_lqvld_1c,
        input mem_skidbuf_s o_ex_mem_payload
    );
    task automatic test_LoadOperation;
      bit [ADDRWIDTH-1:0] expected_address;
      bit expected_lqvld_1c = 1'b1;
      begin
        // Set up the DUT for a LOAD operation
        i_id_type = `LOAD; // Assuming `LOAD is defined elsewhere as the opcode for load operations
        i_rf_p0_reg = 32'hDEADBEEF; // Example address
        expected_address = i_rf_p0_reg; // Expected address to match the input
        @(posedge i_clk); // Clock the DUT to process the input
        // Check if the load operation is correctly signaled and the payload contains the correct address
        if (o_ex_mem_lqvld_1c !== expected_lqvld_1c) begin
          $display("FAILED: test_LoadOperation - o_ex_mem_lqvld_1c not asserted as expected.");
        end
        else if (o_ex_mem_payload.mem_addr !== expected_address) begin
          $display("FAILED: test_LoadOperation - o_ex_mem_payload.mem_addr does not match expected address.");
        end
        else begin
          $display("PASSED: test_LoadOperation");
        end
      end
    endtask
    endmodule
""",
        """
module test_StoreOperation
    #(
        parameter logic signed[31:0] INCL_VEC = 0,
        parameter logic signed[31:0] VLEN = 128,
        parameter logic signed[31:0] ADDRWIDTH = 40,
        parameter logic signed[31:0] ST_DATA_WIDTH_BITS = 128,
        parameter logic signed[31:0] LQ_DEPTH_LOG2 = 3,
        parameter logic signed[31:0] XLEN = 32
    )
    (
        input logic i_clk,
        output logic[4:0] i_id_type,
        output logic[63:0] i_rf_p0_reg,
        output logic[63:0] i_rf_p1_reg,
        input logic o_ex_mem_lqvld_1c,
        input mem_skidbuf_s o_ex_mem_payload
    );
    task automatic test_StoreOperation;
      begin
        // Set initial conditions for a STORE operation
        i_id_type = `STORE; // Assuming `STORE is a defined macro for store operation type
        i_rf_p0_reg = 32'hAABBCCDD; // Example address
        i_rf_p1_reg = 32'h11223344; // Example data to store
        // Expected behavior: o_ex_mem_lqvld_1c is asserted and o_ex_mem_payload contains correct details
        @(posedge i_clk);
        // Check if o_ex_mem_lqvld_1c is asserted and payload matches expected values
        if (o_ex_mem_lqvld_1c == 1'b1 && 
            o_ex_mem_payload.mem_addr == 32'hAABBCCDD && 
            o_ex_mem_payload.mem_store_data == 32'h11223344 && 
            o_ex_mem_payload.mem_store == 1'b1) begin
          $display("PASSED: test_StoreOperation");
        end else begin
          $display("FAILED: test_StoreOperation");
        end
      end
    endtask
    endmodule
""",
        """
module test_BranchMispredict
    #(
        parameter logic signed[31:0] INCL_VEC = 0,
        parameter logic signed[31:0] VLEN = 128,
        parameter logic signed[31:0] ADDRWIDTH = 40,
        parameter logic signed[31:0] ST_DATA_WIDTH_BITS = 128,
        parameter logic signed[31:0] LQ_DEPTH_LOG2 = 3,
        parameter logic signed[31:0] XLEN = 32
    )
    (
        input logic i_clk,
        output logic[36:0] i_if_ex_deco,
        output logic i_if_ex_predicted,
        output logic[4:0] i_id_type,
        input logic o_ex_bp_mispredict
    );
    task automatic test_BranchMispredict;
      begin
        // Set initial conditions for a branch operation with incorrect prediction
        i_id_type = `BRANCH; // Assuming `BRANCH is defined elsewhere as the type for branch instructions
        i_if_ex_predicted = 1'b1; // Assume branch is predicted taken
        i_if_ex_deco = {37{1'b0}}; // Assuming no specific decode information is needed for this test
        i_if_ex_deco[0] = 1'b1; // Set a condition to simulate branch not taken (mispredict scenario)
        // Clock the DUT for the active edge
        @(posedge i_clk);
        // Check if the branch mispredict signal is asserted
        if (o_ex_bp_mispredict == 1'b1) begin
          $display("PASSED: test_BranchMispredict");
        end 
        else begin
          $display("FAILED: test_BranchMispredict");
        end
      end
    endtask
    endmodule
""",
    ]

    result = add_type_aliases_to_module(
        Module.model_validate(dut_parsed_model), codeblocks
    )
    assert len(result) == len(codeblocks)
    assert result[0].count("typedef struct packed") == 0
    assert result[1].count("typedef struct packed") == 1
    assert result[2].count("typedef struct packed") == 1
    assert result[3].count("typedef struct packed") == 0
    assert result[1].count("module test_LoadOperation") == 1
    assert result[1].count("} mem_skidbuf_s;") == 1
    assert result[1].count("task automatic test_LoadOperation") == 1
    assert result[2].count("} mem_skidbuf_s;") == 1
    assert result[2].count("module test_StoreOperation") == 1
    assert result[2].count("task automatic test_StoreOperation") == 1
    assert result[3].count("module test_BranchMispredict") == 1
    assert result[3].count("task automatic test_BranchMispredict") == 1
