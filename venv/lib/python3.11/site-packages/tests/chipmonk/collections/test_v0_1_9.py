"""Test module for chipstack_common.chipmonk.versions.0_1_9"""

import logging

from chipstack_common.chipmonk.catalog import ChipmonkCatalog
from chipstack_common.chipmonk.collections.v0_1_9 import (
    Chipmonk_0_1_9,
    CHIPMONK_VERSION,
)


def test_catalog_fetching():
    assert ChipmonkCatalog.for_version(CHIPMONK_VERSION) is not None
    assert (
        ChipmonkCatalog.for_version(
            CHIPMONK_VERSION, logger=logging.getLogger(__name__)
        )
        is not None
    )


_PARSED_DESIGN = {
    "inputPorts": ["in_a", "in_b"],
    "resetPorts": ["rst"],
    "outputPorts": ["out_a", "out_b"],
    "internalSignals": ["internal_signal"],
}
"""
A default parsed design containing a mix of input, reset, and output ports, and internal signals.

Contains the following ports:
    inputPorts: in_a, in_b
    resetPorts: rst
    outputPorts: out_a, out_b
    internalSignals: internal_signal
"""


def test_get_scenarios_prompts():
    chipmonk = Chipmonk_0_1_9()
    scenarios_task = chipmonk.get_scenarios(
        file_contents="some verilog code",
        parsed_design=_PARSED_DESIGN,
    )

    all_prompts = [t.messages()[0].content for t in scenarios_task.task_rounds()]

    p1 = """Consider the following RTL written in Systemverilog:
```systemverilog
some verilog code
```

Your task is to generate important scenarios to test in the above RTL with formal verification. Write scenarios that test the reset behavior of the output ports of the design. Here are the reset ports and output ports of the design:

## Reset Ports:
- `rst`

## Output Ports:
- `out_a`
- `out_b`

Write as many important scenarios as necessary. Be specific. Use the above port names whenever needed. Each scenario must use at least one Output Port. First generate a step-by-step reasoning And generate scenarios that are implementable in code. Respond in the following JSON list format:
```json
[{"thought": "<step-by-step reasoning on how you arrived at this scenario>", "scenario": "Assert that when <pre-condition>, then <check>"}, ...]
```"""

    p2 = """Consider the following RTL written in Systemverilog:
```systemverilog
some verilog code
```

Your task is to generate important scenarios to test in the above RTL with formal verification. Write scenarios that test the end-to-end functionality of the output ports of the design when the given input ports are driven. Here are the input ports and output ports of the design:

## Input Ports:
- `in_a`
- `in_b`

## Output Ports:
- `out_a`
- `out_b`

Write as many important scenarios as necessary. Be specific. Use the above port names whenever needed. Each scenario must use at least one Output Port. First generate a step-by-step reasoning And generate scenarios that are implementable in code. Respond in the following JSON list format:
```json
[{"thought": "<step-by-step reasoning on how you arrived at this scenario>", "scenario": "Assert that when <pre-condition>, then <check>"}, ...]
```"""

    p3 = """Consider the following RTL written in Systemverilog:
```systemverilog
some verilog code
```

Your task is to generate important scenarios to test in the above RTL with formal verification. Write scenarios that tests the main-functionality of the given output ports of the design. Here are the output ports of the design:

## Output Ports:
- `out_a`
- `out_b`

Write as many important scenarios as necessary. Be specific. Use the above port names whenever needed. Each scenario must use at least one Output Port. First generate a step-by-step reasoning And generate scenarios that are implementable in code. Respond in the following JSON list format:
```json
[{"thought": "<step-by-step reasoning on how you arrived at this scenario>", "scenario": "Assert that when <pre-condition>, then <check>"}, ...]
```"""

    assert p1 in all_prompts
    assert p2 in all_prompts
    assert p3 in all_prompts


def test_parse_responses_internal_signals_dropped():
    chipmonk = Chipmonk_0_1_9()
    scenarios_task = chipmonk.get_scenarios(
        file_contents="some verilog code",
        parsed_design=_PARSED_DESIGN,
    )
    parsed_responses = scenarios_task.parse_responses(
        [
            '[{"scenario": "Assert that \'internal_signal\' is cool"}]',
            '[{"scenario": "Assert that \'in_a\' is cool"}]',
        ]
    )

    assert parsed_responses == ["Assert that 'in_a' is cool"]


def test_parse_responses_flattened():
    chipmonk = Chipmonk_0_1_9()
    scenarios_task = chipmonk.get_scenarios(
        file_contents="some verilog code",
        parsed_design=_PARSED_DESIGN,
    )
    parsed_responses = scenarios_task.parse_responses(
        [
            '[{"scenario": "Assert that \'in_a\' is cool"}, {"scenario": "Assert that \'in_b\' is cool"}]',
            '[{"scenario": "Assert that \'rst\' is cool"}, {"scenario": "Assert that \'out_a\' is cool"}]',
        ]
    )

    assert parsed_responses == [
        "Assert that 'in_a' is cool",
        "Assert that 'in_b' is cool",
        "Assert that 'rst' is cool",
        "Assert that 'out_a' is cool",
    ]


def test_parse_responses_partial_json_list():
    chipmonk = Chipmonk_0_1_9()
    scenarios_task = chipmonk.get_scenarios(
        file_contents="some verilog code",
        parsed_design=_PARSED_DESIGN,
    )
    parsed_responses = scenarios_task.parse_responses(
        [
            '[{"scenario": "Assert that \'in_a\' is cool"}, {"scena',
            '[{"scenario": "Assert that \'rst\' is cool"}, {"scenario": "Assert that \'out_a\' is ',
        ]
    )

    assert parsed_responses == [
        "Assert that 'in_a' is cool",
        "Assert that 'rst' is cool",
    ]
