"""
This file contains the UnitTests class, which provides the following:
- end-to-end functionality for generating, fixing, and running unit tests for a given DUT and dependency files.
- combines formal and simulation unit tests flows
"""

import json
import os
import re
import shutil
import tempfile
from typing import TextIO

from chipstack_client.client_v2 import ClientV2
from chipstack_client.models.syntax_correction import SyntaxCorrection


class UnitTests:
    """
    A class that combines formal and simulation unit tests.
    """

    def __init__(
        self,
        client: ClientV2,
        test_flow: str,
        dut_path: str,
        dependency_paths: list[str],
        syntax_check_provider="slang",
    ):
        self.test_flow = test_flow
        self.top_file = open(dut_path, "r")
        self.dependency_files: list[TextIO] = [
            open(file, "r") for file in dependency_paths
        ]
        self.syntax_check_provider = syntax_check_provider
        self.client = client
        self.parsed_design: dict = {}
        self.mental_model: dict = {}
        self.scenarios: list = []
        self.testbench_name: str = ""
        self.testbench: str = ""
        self.testbench_after_syntax_fix: str = ""
        self.run_results: dict = {}
        self.syntax_correction: SyntaxCorrection = SyntaxCorrection([])

    def reset_file_pointer(self):
        """Reset the file pointer to the beginning of the file."""
        self.top_file.seek(0)
        for file in self.dependency_files:
            file.seek(0)

    def generate_unit_tests(self) -> str:
        """
        Generate unit tests for the given DUT and dependency files.

        Returns:
            testbench (str): The generated unit test.

        """
        # Step 1: Parse the design
        self.reset_file_pointer()
        try:
            self.parsed_design = self.client.parse_design(
                top_file=self.top_file, dependency_files=self.dependency_files
            )
        except Exception as error:
            raise RuntimeError(f"Error parsing design: {error}") from error

        # Step 2: Generate the mental model
        self.reset_file_pointer()
        try:
            self.mental_model = self.client.generate_mental_model(
                top_file=self.top_file,
                parsed_design=self.parsed_design,
                unit_test_flow=self.test_flow,
            )
        except Exception as error:
            raise RuntimeError(f"Error generating mental model: {error}") from error

        # Step 3: Generate unit test scenarios
        self.reset_file_pointer()
        try:
            self.scenarios = self.client.generate_unit_test_scenarios(
                self.mental_model,
                rtl_file_contents=self.top_file.read(),
                unit_test_flow=self.test_flow,
            )
        except Exception as error:
            raise RuntimeError(
                f"Error generating unit test scenarios: {error}"
            ) from error

        # Step 4: Generate unit tests
        self.reset_file_pointer()
        try:
            testbench_obj = self.client.generate_unit_tests(
                mental_model=self.mental_model,
                scenarios=self.scenarios,
                parsed_design=self.parsed_design,
                rtl_file_contents=self.top_file.read(),
                unit_test_flow=self.test_flow,
            )
            self.testbench_name = testbench_obj.get(
                "name", f"unit_test_{self.parsed_design['name']}"
            )
            self.testbench = testbench_obj["code"]
        except Exception as error:
            raise RuntimeError(f"Error generating unit tests: {error}") from error

        return self.testbench

    def fix_syntax(self, max_attempts: int = 3) -> str:
        """
        Fix syntax issues in the generated unit tests.

        Returns:
            None

        """
        # Step 1: Decompose the unit tests to get the codeblocks
        decomposed_unit_tests = self.decompose_unit_tests()

        # Step 1.1: Load all the decomposed code blocks into a SyntaxCorrection object
        codeblocks_to_fix = (
            decomposed_unit_tests["tasks"] + decomposed_unit_tests["modules"]
            if self.test_flow == "Simulation"
            else decomposed_unit_tests["codeblocks"]
        )
        self.syntax_correction.add_codeblocks(codeblocks_to_fix)

        # Step 2: Iterate over the codeblocks and fix syntax issues
        for cur_attempt in range(max_attempts):
            # Step 2.1: Check the syntax of all the codeblocks
            codeblocks_that_need_syntax_check = []
            # Go through all the codeblocks that had syntax issues in the last attempt
            for codeblock_inst in [
                codeblock
                for codeblock in self.syntax_correction.codeblocks
                if not codeblock.is_syntax_clean
            ]:
                # For the first round, we need to start with the original code, for subsequent rounds, we need to use the corrected code
                code_to_check = codeblock_inst.get_latest_corrected_code()
                errors, warnings = self.syntax_check_codeblock(code_to_check)
                # If there are syntax issues, add them to the list of codeblocks that need syntax check
                if len(errors) + len(warnings) != 0:
                    codeblocks_that_need_syntax_check.append(
                        {
                            "code": code_to_check,
                            "syntax_issues": {"errors": errors, "warnings": warnings},
                            "other_issues": [],
                        }
                    )
                    # If this is not the first attempt, we need to add a new correction to the codeblock
                    if cur_attempt != 0:
                        codeblock_inst.add_new_correction(code_to_check)
                    codeblock_inst.update_latest_correction_result(errors, warnings)
                else:
                    codeblock_inst.is_syntax_clean = True

            # If there are no codeblocks with syntax issues, we can break
            if not codeblocks_that_need_syntax_check:
                break

            # Step 3: Perform syntax correction on the codeblocks that need it
            corrected_codes = self.client.fix_syntax_of_unit_tests(
                mental_model=self.mental_model,
                dut_parsed_model=self.parsed_design,
                correction_contexts=codeblocks_that_need_syntax_check,
                unit_test_flow=self.test_flow,
            )

            # Step 3.1: Update the codeblocks with the corrected code
            for idx, codeblock_inst in enumerate(
                [
                    codeblock
                    for codeblock in self.syntax_correction.codeblocks
                    if not codeblock.is_syntax_clean
                ]
            ):
                output_code_key = (
                    "output_code" if self.test_flow == "Simulation" else "code"
                )
                corrected_code = corrected_codes[idx][output_code_key]
                codeblock_inst.add_fixed_code_to_latest_correction(corrected_code)

            print(
                f"[INFO] Syntax correction attempt {cur_attempt + 1} for design {self.parsed_design['name']} completed"
            )

        # Step 4: Compose the unit tests after fixing syntax issues
        return self.compose_unit_tests(decomposed_unit_tests)

    def decompose_unit_tests(self):
        """Decompose the unit tests to get the codeblocks."""
        decomposed_unit_tests = self.client.decompose_unit_tests(
            self.testbench,
            unit_test_flow=self.test_flow,
            dut_parsed_model=self.parsed_design,
        )
        if self.test_flow == "Simulation":
            if (
                "modules" not in decomposed_unit_tests
                or "tasks" not in decomposed_unit_tests
            ):
                raise RuntimeError("Error: No modules or tasks found in testbench")
        else:
            if "codeblocks" not in decomposed_unit_tests:
                raise RuntimeError("Error: No codeblocks found in testbench")

        return decomposed_unit_tests

    def compose_unit_tests(self, decomposed_unit_tests) -> str:
        """
        Compose the unit tests after fixing syntax issues.

        Returns:
            testbench (str): The composed unit test.

        """
        # Step 1: Add all the syntax-corrected codeblocks to the list of codeblocks to compose
        codeblocks_to_compose: dict[str, list[str]] = {}
        if self.test_flow == "Simulation":
            # In simulation flow, we differentiate between tasks and modules
            codeblocks_to_compose["tasks"] = []
            codeblocks_to_compose["modules"] = []
            task_idx = len(decomposed_unit_tests["tasks"])
            for cb in self.syntax_correction.codeblocks[:task_idx]:
                if cb.is_syntax_clean:
                    codeblocks_to_compose["tasks"].append(
                        cb.get_latest_corrected_code()
                    )

            for cb in self.syntax_correction.codeblocks[task_idx:]:
                if cb.is_syntax_clean:
                    codeblocks_to_compose["modules"].append(
                        cb.get_latest_corrected_code()
                    )

            # Compose the simulation unit tests
            unit_test_tb = self.client.compose_simulation_unit_tests(
                tasks=codeblocks_to_compose["tasks"],
                modules=codeblocks_to_compose["modules"],
                dut_parsed_model=self.parsed_design,
            )
        else:
            codeblocks_to_compose["modules"] = []

            for cb in self.syntax_correction.codeblocks:
                if cb.is_syntax_clean:
                    codeblocks_to_compose["modules"].append(
                        cb.get_latest_corrected_code()
                    )

            unit_test_tb = self.client.compose_formal_unit_tests(
                codeblocks=codeblocks_to_compose["modules"],
                dut_parsed_model=self.parsed_design,
            )

        assert "code" in unit_test_tb, "Error composing unit tests"
        self.testbench_after_syntax_fix = unit_test_tb["code"]
        return self.testbench_after_syntax_fix

    def run_unit_tests(self, sva_file_path) -> dict:
        """
        Run the generated unit tests.

        Returns:
            None

        """
        monitor_file = open(sva_file_path, "r")
        self.reset_file_pointer()
        if self.test_flow == "Formal":
            try:
                self.run_results = self.client.run_formal_tests(
                    module_name=self.parsed_design["name"],
                    clocks=[
                        clock["name"] for clock in self.parsed_design["clockPorts"]
                    ],
                    resets=[
                        reset["name"] for reset in self.parsed_design["resetPorts"]
                    ],
                    dut_files=[self.top_file] + self.dependency_files,
                    sva_files=[monitor_file],
                )
                return self.run_results
            except json.JSONDecodeError as error:
                raise RuntimeError(f"Error running formal tests: {error}") from error
            except Exception as error:
                raise RuntimeError(
                    f"Unexpected error running formal tests: {error}"
                ) from error
            finally:
                monitor_file.close()
        else:
            try:
                self.run_results = self.client.run_simulation_tests(
                    dut_files=self.dependency_files + [self.top_file],
                    testbench_files=[monitor_file],
                )
                return self.run_results
            except Exception as error:
                raise RuntimeError(
                    f"Error running simulation tests: {error}"
                ) from error
            finally:
                monitor_file.close()

    def syntax_check_codeblock(self, codeblock: str) -> tuple[list[str], list[str]]:
        """Given a codeblock, check its syntax and return the errors and warnings."""
        try:
            # We need to write the codeblock to a file to perform syntax checking
            tmp_dir = tempfile.mkdtemp()
            codeblock_name = re.findall(r"module\s+(\w+)", codeblock)[0] or "tmp"
            codeblock_filename = os.path.join(tmp_dir, f"{codeblock_name}.sv")
            with open(codeblock_filename, "w") as file:
                file.write(codeblock)
            sva_file = open(codeblock_filename, "r")

            if (
                self.test_flow == "Simulation"
                and self.syntax_check_provider == "cadence"
            ):
                syntax_result = self.client.simulation_syntax_check([sva_file]).get(
                    "log", {}
                )

            elif self.test_flow == "Formal" and self.syntax_check_provider == "cadence":
                syntax_result = self.client.jasper_syntax_check(
                    module_name=self.parsed_design["name"],
                    clocks=[
                        clock["name"] for clock in self.parsed_design["clockPorts"]
                    ],
                    resets=[
                        reset["name"] for reset in self.parsed_design["resetPorts"]
                    ],
                    dut_files=[],
                    sva_files=[sva_file],
                )
            elif self.syntax_check_provider == "slang":
                syntax_result = self.client.slang_compile_check(
                    files=[sva_file],
                )
            else:
                raise RuntimeError(
                    f"Error: Invalid syntax check provider {self.syntax_check_provider}"
                )

            # Extract the errors and warnings
            errors = syntax_result.get("errors", [])
            warnings = syntax_result.get("warnings", [])

            # We need to filter out specific warnings
            warnings = [
                w
                for w in warnings
                if "xmsim: *W,RNQUIE: Simulation is complete." not in w
            ]
            return errors, warnings

        except Exception as error:
            raise RuntimeError(
                f"Error checking syntax of codeblock: {error}"
            ) from error
        finally:
            # cleanup the temp folder
            sva_file.close()
            shutil.rmtree(tmp_dir)

    def close_files(self):
        """
        Close all open files.

        Returns:
            None

        """
        self.top_file.close()
        for file in self.dependency_files:
            file.close()

    def generate_fix_run(self) -> dict:
        """
        Generate, fix, and run unit tests.

        Returns:
            None

        """
        self.generate_unit_tests()
        fixed_code = self.fix_syntax()
        # save to a temp file
        # Create a temporary file
        with tempfile.NamedTemporaryFile(delete=False, suffix=".sv") as temp_file:
            # Write the string to the temp file
            temp_file.write(fixed_code.encode("utf-8"))
            temp_file_path = temp_file.name

        # Use the temporary file
        run_results = self.run_unit_tests(temp_file_path)
        self.close_files()

        # Remove the temporary file
        os.unlink(temp_file_path)

        return run_results


if __name__ == "__main__":
    # Example usage of the UnitTests class
    client = ClientV2()
    unit_tests = UnitTests(
        client=client,
        test_flow="Simulation",
        # add file to path + eval_set
        dut_path=os.path.join(
            os.path.dirname(__file__), "kpi/eval_set/async_fifo/async_fifo.sv"
        ),
        dependency_paths=[],
        syntax_check_provider="slang",
    )
    run_results = unit_tests.generate_fix_run()
    print(run_results)
