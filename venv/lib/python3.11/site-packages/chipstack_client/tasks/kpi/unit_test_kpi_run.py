"""
We will take a file that contains the following information:
<file path .v or .sv>, <dependency filelist.f path>
...

We will parse this file and run the formal verification for each design in the file. We will save the output of the formal verification in a directory named after the design. We will also save the parsed design, mental model, scenarios, testbench, and monitor code in the output directory.

Example usage:
python kpi_formal_run.py design_file.yaml output_dir
"""

import argparse
import csv
import logging
import json
import os
import traceback
import time
import yaml

from chipstack_client.tasks.kpi.unit_test_kpi_analyze import UnitTestAnalyze
from chipstack_client.client_v2 import ClientV2
from chipstack_client.tasks.unit_tests import UnitTests  # type: ignore

# Configuration
NUM_SYNTAX_CORRECTION_ATTEMPTS = 3
LOG_FORMAT = "%(asctime)s - %(levelname)s - %(message)s"

# Setup logger
logging.basicConfig(level=logging.INFO, format=LOG_FORMAT)
logger = logging.getLogger()


def parse_design_file(file_path: str) -> dict:
    """
    Parses a design file in YAML format and returns a dictionary of designs to run, including the dependencies loaded from a `.f` file.

    Args:
        file_path (str): The path to the design file. The file should be in YAML format and contain a list of designs to run, where each entry is a dictionary with the following keys:
            - "top_rtl_path": The path to the top RTL file.
            - "dependency_file": The path to the `.f` file that lists all dependency files, can be empty.

    Returns:
        dict: A dictionary containing the designs to run, where the keys are the design names
              and the values are dictionaries with the following keys:
              - "top_rtl_path": The path to the top RTL file.
              - "dependency_paths": A list of paths to the dependency files.

    Raises:
        FileNotFoundError: If the specified file does not exist.
        ValueError: If the design file has an invalid format or dependencies cannot be loaded.
    """
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"No such file: {file_path}")

    base_dir = os.path.dirname(file_path)

    with open(file_path, "r") as file:
        try:
            designs = yaml.safe_load(file)
        except yaml.YAMLError as e:
            raise ValueError(f"Error parsing YAML file: {e}")

        if not isinstance(designs, list):
            raise ValueError(
                "Invalid format: YAML file should contain a list of designs."
            )

        designs_to_run = {}
        for design in designs:
            if not isinstance(design, dict) or "top_rtl_path" not in design:
                raise ValueError(
                    "Invalid format: Each design entry should contain 'top_rtl_path' key."
                )

            rtl_path = design["top_rtl_path"]
            if not os.path.isabs(rtl_path):
                rtl_path = os.path.join(base_dir, rtl_path)
            if not os.path.exists(rtl_path):
                raise FileNotFoundError(f"No such RTL file: {rtl_path}")

            dependency_type = design.get(
                "dependency_type", "files"
            )  # Default to files, can be "files" or "filelist"

            dependencies = []
            dependency_files = []
            if dependency_type == "files":
                dependency_files = design.get("dependency_files", [])
            elif dependency_type == "filelist":
                dependency_filelist = design.get("dependency_file", "")
                if dependency_filelist:
                    if not os.path.isabs(dependency_filelist):
                        dependency_filelist = os.path.join(
                            base_dir, dependency_filelist
                        )
                    if not os.path.exists(dependency_filelist):
                        raise ValueError("No such dependency file: {dependency_file}")
                    with open(dependency_filelist, "r") as f:
                        dependency_files = [
                            os.path.join(base_dir, line.strip())
                            for line in f.readlines()
                        ]
            # Convert all the relative paths to absolute paths
            if dependency_files:
                for dep in dependency_files:
                    if not os.path.isabs(dep):
                        dep_path = os.path.join(base_dir, dep)
                    if not os.path.exists(dep_path):
                        raise FileNotFoundError(f"No such dependency file: {dep_path}")

                    dependencies.append(dep_path)

            design_name = os.path.basename(rtl_path).split(".")[0]
            designs_to_run[design_name] = {
                "top_rtl_path": rtl_path,
                "dependency_paths": dependencies,
            }

    return designs_to_run


def run_designs(
    design_file: str,
    output_dir: str,
    syntax_check_provider: str,
    server_url: str,
    eda_url: str,
):
    """
    Run the formal verification for multiple designs specified in a design file.

    Args:
        design_file (str): The path to the design file.
        output_dir (str): The path to the output directory for the designs.

    Returns:
        None

    """
    client = ClientV2(chipstack_python_server=server_url, chipstack_eda_server=eda_url)
    designs_to_run = parse_design_file(design_file)
    run_types = ["Formal", "Simulation"]
    for run_type in run_types:
        kpis = [
            [
                "Design Name",
                "Scenarios Generated",
                "Scenarios w/ Syntax Errors After First Generation",
                "Scenarios w/ Syntax Errors Remaining",
                "Run Status",
                "Passed Scenarios",
                "Failed Scenarios",
                "Total Coverage",
            ],
        ]

        run_out_dir = os.path.join(output_dir, run_type)
        if not os.path.exists(run_out_dir):
            os.makedirs(run_out_dir)
        for design_name, design_info in designs_to_run.items():
            try:
                start = time.time()
                unit_test_inst = UnitTests(
                    client=client,
                    dut_path=design_info["top_rtl_path"],
                    dependency_paths=design_info["dependency_paths"],
                    test_flow=run_type,
                    syntax_check_provider=syntax_check_provider,
                )
                unit_test_inst.generate_fix_run()
                analyzer = UnitTestAnalyze(unit_test_inst)
                analyzer.analyze()
                kpi = analyzer.dump_unit_test_metadata(
                    os.path.join(run_out_dir, design_name)
                )
                kpis.append(kpi)
                print(
                    f"Design {design_name} completed in {time.time() - start} seconds"
                )
            except Exception as e:
                print("".join(traceback.TracebackException.from_exception(e).format()))
                print(f"Error running design {design_name}: {e}")
                continue
        # Save KPIs as csv
        with open(os.path.join(run_out_dir, "kpi.csv"), "w") as f:
            writer = csv.writer(f)
            writer.writerows(kpis)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Run formal verification for multiple designs."
    )
    parser.add_argument(
        "--design_file",
        type=str,
        help="Path to the design file.",
        default=os.path.join(os.path.dirname(__file__), "example.yaml"),
    )
    parser.add_argument(
        "--output_dir",
        type=str,
        help="Path to the output directory.",
        default=os.path.join(os.path.dirname(__file__), "example_output"),
    )
    parser.add_argument(
        "--server_url",
        type=str,
        help="URL of the Chipstack server.",
        default="https://api.chipstack.ai/v2/",
    )
    parser.add_argument(
        "--eda_url",
        type=str,
        help="URL of the EDA server.",
        default="https://eda-sea.chipstack.ai:8443/",
    )
    parser.add_argument(
        "--syntax_check_provider",
        type=str,
        help="Syntax check provider to use.",
        default="cadence",
    )
    args = parser.parse_args()
    # Dump the run configuration in the output directory
    if not os.path.exists(args.output_dir):
        os.makedirs(args.output_dir)
    with open(os.path.join(args.output_dir, "run_config.json"), "w") as f:
        json.dump(vars(args), f, indent=4)
    run_designs(
        design_file=args.design_file,
        output_dir=args.output_dir,
        syntax_check_provider=args.syntax_check_provider,
        server_url=args.server_url,
        eda_url=args.eda_url,
    )
