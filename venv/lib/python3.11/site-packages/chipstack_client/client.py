import os
import requests
import json
import tempfile

from typing import List

# Import the .env file two levels up
from dotenv import load_dotenv

file_dir = os.path.dirname(os.path.abspath(__file__))
load_dotenv(dotenv_path=os.path.join(file_dir, "../.env"))

ENGINE_ENDPOINTS_PREFIX = "engine/"
EDA_ENDPOINTS_PREFIX = "eda/"
USER_ENDPOINTS_PREFIX = "users/"

AUTHORIZATION_ENDPOINT = "generate-token"
UPLOAD_FILE_ENDPOINT = "upload-file"
GENERATE_MENTAL_MODEL_ENDPOINT = "generate-mental-model"
GENERATE_UNIT_TEST_ENDPOINT = "get-unit-tests"
GENERATE_UNIT_TEST_SCENARIO_ENDPOINT = "get-unit-test-scenarios"
GET_SIGNALS_ENDPOINT = "get-signals"
PARSE_ENDPOINT = "parse"
INVOKE_JASPER_ENDPOINT = "invoke-jasper"
INVOKE_XCELIUM_ENDPOINT = "invoke-xcelium"


class Client(object):
    def __init__(
        self,
        api_key=os.environ.get("CHIPSTACK_LICENSE_KEY", ""),
        endpoint=os.environ.get("CHIPSTACK_HOST", "http://localhost:3001/v1/"),
    ):
        """
        The function initializes an object with an API key and an endpoint URL, defaulting to a local
        host if no endpoint is provided.

        :param api_key: The `api_key` parameter is a string that represents the API key used for
        authentication in the API requests. Reach out to ChipStackAI to get an API key.
        :param endpoint: Either a string or None. If a string, it represents the URL of the API.
        """
        assert api_key, "You must provide a valid API key"
        self.license = api_key
        self.endpoint = endpoint

        def _authorize(self):
            url = f"{self.endpoint}{USER_ENDPOINTS_PREFIX}{AUTHORIZATION_ENDPOINT}"
            payload = json.dumps({"licenseKey": self.license})
            headers = {"Content-Type": "application/json"}

            response = requests.request("POST", url, headers=headers, data=payload)
            assert response.status_code == 200, "Response status code is not 200"

            response = response.json()
            if not response["isValid"]:
                raise Exception("Invalid license key")

            return response["token"]["accessToken"]

        self.bearer = _authorize(self)
        self.auth_header = {"Authorization": "Bearer " + self.bearer}

    def upload_file(self, filepath) -> str:
        """
        The `upload_file` function uploads a file to a specified endpoint using a POST request with
        necessary headers and returns the hash of the uploaded file.

        :param filepath: The `filepath` parameter is the path to the file
        that you want to upload. It should be a string representing the full path to the file on your
        local system
        :return: a context ID
        """
        filename = filepath.split("/")[-1]
        url = self.endpoint + ENGINE_ENDPOINTS_PREFIX + UPLOAD_FILE_ENDPOINT
        files = [
            (
                "file",
                (
                    filename,
                    open(filepath, "rb"),
                    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                ),
            )
        ]
        headers = self.auth_header

        response = requests.request("POST", url, headers=headers, files=files)

        return response.json()["hash"]

    def generate_mental_model(self, contextId, test_type="Simulation"):
        """
        The `generate_mental_model` function generates a mental model for a given context ID and test plan type.

        :param contextId: The `contextId` parameter is a string that represents the context ID of the file. Typically returned by the `upload_file` function.
        :param test_type: The `test_type` parameter is a string that represents the type of test plan to be generated. It defaults to "Simulation".
        """
        url = self.endpoint + ENGINE_ENDPOINTS_PREFIX + GENERATE_MENTAL_MODEL_ENDPOINT
        payload = json.dumps({"contextId": contextId, "testPlanType": test_type})
        headers = {"Content-Type": "application/json"}
        headers.update(self.auth_header)
        response = requests.request("POST", url, headers=headers, data=payload)
        if response.status_code != 200:
            raise Exception(response.text)
        return response.json()

    def parse_design(self, top_rtl_file, dependencies=[]):
        """
        The `parse_design` function parses a given top RTL file and dependencies to extract and return module name, clocks, resets, params, ... in a jason format.

        :param top_rtl_file: The `top_rtl_file` parameter is a string that represents the content of the top RTL file.
        :param dependencies: The `dependencies` parameter is a list of strings that represents the content of other RTL files.
        """
        url = self.endpoint + EDA_ENDPOINTS_PREFIX + PARSE_ENDPOINT

        # List to store the temporary files
        temp_file_names = []
        file_list = []

        # Create multiple temporary files
        try:
            with tempfile.NamedTemporaryFile(mode="w", delete=False) as temp_file:
                temp_file.write(top_rtl_file)
                temp_file_names.append(temp_file.name)

            fr = open(temp_file.name, "r")
            file_list.append(
                ("top_file", (temp_file.name, fr, "verilog/systenverilog"))
            )

        except IOError as e:
            print("Error writing to temporary file {}: {}".format(temp_file.name, e))

        for dep_file_content in dependencies:
            try:
                with tempfile.NamedTemporaryFile(mode="w", delete=False) as temp_file:
                    temp_file.write(dep_file_content)
                    temp_file_names.append(temp_file.name)

                fr = open(temp_file.name, "r")
                file_list.append(
                    ("dependencies", (temp_file.name, fr, "verilog/systenverilog"))
                )

            except IOError as e:
                print(
                    "Error writing to temporary file {}: {}".format(temp_file.name, e)
                )

        headers = self.auth_header

        response = requests.request("POST", url, headers=headers, files=file_list)
        if response.status_code != 200:
            raise Exception(response.text)

        for temp_file in file_list:
            temp_file[1][1].close()

        for temp_file in temp_file_names:
            if temp_file and os.path.exists(temp_file):
                os.remove(temp_file)

        return response.json()

    def generate_unit_tests(self, rtl_file_content, parsed_design, test_type="Formal"):
        """
        The `generate_unit_tests` function generates unit tests for a given RTL file content and test plan type.

        :param rtl_file_content: The `rtl_file_content` parameter is a string that represents the content of the RTL file.
        :param parsed_design: The `parsed_design` parameter is in jason format and represents the parsed format of the top RTL file and it'
        s dependencies.
        :param test_type: The `test_type` parameter is a string that represents the type of test plan to be generated. It defaults to "Formal".
        """
        url = self.endpoint + ENGINE_ENDPOINTS_PREFIX + GENERATE_UNIT_TEST_ENDPOINT
        payload = json.dumps(
            {
                "contextId": "",
                "fileContent": rtl_file_content,
                "parsedResult": parsed_design,
                "type": test_type,
            }
        )
        headers = {"Content-Type": "application/json"}
        headers.update(self.auth_header)

        response = requests.request("POST", url, headers=headers, data=payload)
        if response.status_code != 200:
            raise Exception(response.text)
        return response.json()

    def generate_unit_test_scenarios(
        self, rtl_file_content, parsed_design, test_type="Formal"
    ):
        """
        The `generate_unit_test_scenarios` function generates unit test scenarios for a given RTL file content and test plan type.

        :param rtl_file_content: The `rtl_file_content` parameter is a string that represents the content of the RTL file.
        :param parsed_design: The `parsed_design` parameter is in jason format and represents the parsed format of the top RTL file and it'
        s dependencies.
        :param test_type: The `test_type` parameter is a string that represents the type of test plan to be generated. It defaults to "Formal".
        """
        url = (
            self.endpoint
            + ENGINE_ENDPOINTS_PREFIX
            + GENERATE_UNIT_TEST_SCENARIO_ENDPOINT
        )
        payload = json.dumps(
            {
                "contextId": "",
                "fileContent": rtl_file_content,
                "parsedResult": parsed_design,
                "type": test_type,
            }
        )
        headers = {"Content-Type": "application/json"}
        headers.update(self.auth_header)

        response = requests.request("POST", url, headers=headers, data=payload)
        if response.status_code != 200:
            raise Exception(response.text)
        return response.json()

    def get_signals(self, signals, rtl_file_content):
        url = self.endpoint + ENGINE_ENDPOINTS_PREFIX + GET_SIGNALS_ENDPOINT
        payload = json.dumps(
            {
                "contextId": "",
                "signals": signals,
                "fileContent": rtl_file_content,
            }
        )
        headers = {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + self.bearer,
        }
        response = requests.request("POST", url, headers=headers, data=payload)
        if response.status_code != 200:
            raise Exception(response.text)
        return response.json()

    def invoke_jasper(
        self, jasper_config: str, dut_files: List[str], sva_files: List[str]
    ):

        url = self.endpoint + EDA_ENDPOINTS_PREFIX + INVOKE_JASPER_ENDPOINT

        # List to store the temporary files
        temp_file_names = []
        file_list = []

        if not jasper_config:
            raise ValueError("[ERROR] jasper_config is null.")
        else:
            try:
                with tempfile.NamedTemporaryFile(mode="w", delete=False) as temp_file:
                    temp_file.write(jasper_config)
                    temp_file_names.append(temp_file.name)

                fr = open(temp_file.name, "r")
                file_list.append(
                    ("jasper_config", (temp_file.name, fr, "verilog/systenverilog"))
                )
            except IOError as e:
                print(
                    "Error writing to temporary file {}: {}".format(temp_file.name, e)
                )

        # Create multiple temporary files
        for i, dut_file in enumerate(dut_files):
            if not dut_file:
                raise ValueError(f"[ERROR] dut_files#{i} is null.")
            try:
                with tempfile.NamedTemporaryFile(mode="w", delete=False) as temp_file:
                    temp_file.write(dut_file)
                    temp_file_names.append(temp_file.name)

                fr = open(temp_file.name, "r")
                file_list.append(
                    ("dut_files", (temp_file.name, fr, "verilog/systenverilog"))
                )

            except IOError as e:
                print(
                    "Error writing to temporary file {}: {}".format(temp_file.name, e)
                )

        for i, sva_file in enumerate(sva_files):
            if not sva_file:
                raise ValueError(f"[ERROR] sva_files#{i} is null.")
            try:
                with tempfile.NamedTemporaryFile(mode="w", delete=False) as temp_file:
                    temp_file.write(sva_file)
                    temp_file_names.append(temp_file.name)

                fr = open(temp_file.name, "r")
                file_list.append(
                    ("sva_files", (temp_file.name, fr, "verilog/systenverilog"))
                )

            except IOError as e:
                print(
                    "Error writing to temporary file {}: {}".format(temp_file.name, e)
                )

        headers = self.auth_header

        response = requests.request("POST", url, headers=headers, files=file_list)
        if response.status_code != 200:
            raise Exception(response.text)

        for temp_file in file_list:
            temp_file[1][1].close()

        for temp_file in temp_file_names:
            if temp_file and os.path.exists(temp_file):
                os.remove(temp_file)

        return response.json()

    def invoke_xcelium(self, dut_files: List[str], dv_files: List[str]):

        url = self.endpoint + EDA_ENDPOINTS_PREFIX + INVOKE_XCELIUM_ENDPOINT

        # List to store the temporary files
        file_list, temp_file_names = [], []

        for i, file in enumerate(dut_files + dv_files):
            if not file:
                if i < len(dut_files):
                    raise ValueError(f"[ERROR] dut_files#{i} is null.")
                else:
                    raise ValueError(f"[ERROR] dv_files#{i} is null.")
            try:

                template = "file_" if i < len(dut_files) else "dv_file_"
                with tempfile.NamedTemporaryFile(
                    mode="w", delete=False, prefix=template, suffix=".sv"
                ) as temp_file:
                    temp_file.write(file)
                    temp_file_names.append(temp_file.name)

                fr = open(temp_file.name, "r")
                file_list.append(
                    ("files", (temp_file.name, fr, "verilog/systenverilog"))
                )

            except IOError as e:
                print(
                    "Error writing to temporary file {}: {}".format(temp_file.name, e)
                )

        headers = self.auth_header

        response = requests.request("POST", url, headers=headers, files=file_list)
        if response.status_code != 200:
            raise Exception(response.text)

        for temp_file in file_list:
            temp_file[1][1].close()

        for temp_file in temp_file_names:
            if temp_file and os.path.exists(temp_file):
                os.remove(temp_file)

        return response.json()
