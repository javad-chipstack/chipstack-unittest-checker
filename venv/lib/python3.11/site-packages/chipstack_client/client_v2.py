"""Client for v2 of the Chipstack API."""

import os
import json
import requests
import warnings
import tempfile
from typing import List, Tuple, Any, Dict, TextIO, Optional

# Import the .env file two levels up
from dotenv import load_dotenv  # type: ignore

file_dir = os.path.dirname(os.path.abspath(__file__))
load_dotenv(dotenv_path=os.path.join(file_dir, "../.env"))

ENGINE_ENDPOINTS_PREFIX = "engine/"
EDA_ENDPOINTS_PREFIX = "eda/"
USER_ENDPOINTS_PREFIX = "users/"

AUTHORIZATION_ENDPOINT = "generate-token"
GENERATE_MENTAL_MODEL_ENDPOINT = "generate-mental-model"
PARSE_ENDPOINT = "parse"
GENERATE_FORMAL_UNIT_TEST_SCENARIO_ENDPOINT = "generate-test-scenarios/formal"
GENERATE_SIMULATION_UNIT_TEST_SCENARIO_ENDPOINT = "generate-test-scenarios/simulation"
GENERATE_FORMAL_UNIT_TEST_ENDPOINT = "generate-unit-tests/formal"
GENERATE_SIMULATION_UNIT_TEST_ENDPOINT = "generate-unit-tests/simulation"
FIX_FORMAL_SYNTAX_ENDPOINT = "fix-syntax-issues/formal"
FIX_SIMULATION_SYNTAX_ENDPOINT = "fix-syntax-issues/simulation"
COMPILE_CHECK_JASPER_ENDPOINT = "compile-check-jasper"
COMPILE_CHECK_SLANG_ENDPOINT = "compile-check-slang"
COMPILE_CHECK_SIMULATION_ENDPOINT = "compile-check-xcelium"
COMPOSE_FORMAL_UNIT_TEST_ENDPOINT = "parse-unit-tests/formal/compose"
COMPOSE_SIMULATION_UNIT_TEST_ENDPOINT = "parse-unit-tests/simulation/compose"
DECOMPOSE_FORMAL_UNIT_TEST_ENDPOINT = "parse-unit-tests/formal/decompose"
DECOMPOSE_SIMULATION_UNIT_TEST_ENDPOINT = "parse-unit-tests/simulation/decompose"
GENERATE_SIMULATION_FUNCTIONAL_COVERAGE_SCENARIO_ENDPOINT = (
    "generate-functional-coverage-scenarios/simulation"
)
GENERATE_SIMULATION_FUNCTIONAL_COVERAGE_CODE_ENDPOINT = (
    "generate-functional-coverage-code/simulation"
)

INVOKE_JASPER_ENDPOINT = "invoke-jasper"
INVOKE_XCELIUM_ENDPOINT = "invoke-xcelium"

V_SV_FILE = "verilog/systemverilog"


def deprecated_argument(arg_name, message):
    def decorator(func):
        def wrapper(*args, **kwargs):
            if arg_name in kwargs:
                warnings.warn(
                    f"'{arg_name}' is deprecated in {func.__name__} and will be removed in a future version. {message}",
                    category=DeprecationWarning,
                    stacklevel=2,
                )
            return func(*args, **kwargs)

        return wrapper

    return decorator


class ClientV2:
    """Client for v2 of the Chipstack API."""

    def __init__(
        self,
        api_key=os.environ.get("CHIPSTACK_LICENSE_KEY", ""),
        chipstack_python_server=os.environ.get(
            "CHIPSTACK_PYTHON_SERVER", "http://localhost:8000/v2/"
        ),
        chipstack_eda_server=os.environ.get(
            "CHIPSTACK_EDA_SERVER", "http://eda.chipstack.ai:81/"
        ),
        bearer=os.environ.get("BEARER_AUTHORIZATION_TOKEN", ""),
    ):
        """
        Initializes a ChipstackClient object.

        Args:
            api_key (str, optional): The API key for accessing the Chipstack API.
                Defaults to the value of the CHIPSTACK_LICENSE_KEY environment variable.
            chipstack_python_server (str, optional): The URL of the Chipstack Python server.
                Defaults to "http://localhost:8000/v2/" or the value of the CHIPSTACK_PYTHON_SERVER environment variable.
            chipstack_eda_server (str, optional): The URL of the Chipstack EDA server.
                Defaults to "http://localhost:8000/v2/" or the value of the CHIPSTACK_EDA_SERVER environment variable.
            bearer (str, optional): The bearer authorization token.
                Defaults to the value of the BEARER_AUTHORIZATION_TOKEN environment variable.

        Raises:
            AssertionError: If the API key is not provided.
            ValueError: If the provided API key is invalid.

        """

        assert api_key, "You must provide a valid API key"
        self.license = api_key
        self.chipstack_python_server = chipstack_python_server
        self.chipstack_eda_server = chipstack_eda_server

        def _authorize(self):
            url = f"{self.chipstack_python_server}{USER_ENDPOINTS_PREFIX}{AUTHORIZATION_ENDPOINT}"
            payload = json.dumps({"licenseKey": self.license})
            headers = {"Content-Type": "application/json"}

            try:
                response = requests.post(url, headers=headers, data=payload)
                response.raise_for_status()
            except (
                requests.exceptions.HTTPError,  # For HTTP errors (4xx and 5xx status codes)
                requests.exceptions.Timeout,  # If the request times out
                requests.exceptions.ConnectionError,  # If a connection to the server cannot be established
                requests.exceptions.TooManyRedirects,  # If the request exceeds the configured number of maximum redirections
                requests.exceptions.InvalidURL,  # If the URL provided is invalid
                requests.exceptions.SSLError,  # For SSL/TLS errors during an HTTPS request
                # SSL/TLS issues can include certificate verification failures,
                # expired certificates, hostname mismatches, or using outdated or insecure SSL/TLS protocols
                requests.exceptions.RequestException,  # General exception
                AssertionError,
            ) as error:
                error_mapping = {
                    requests.exceptions.HTTPError: "HTTPError. Please try again later.",
                    requests.exceptions.Timeout: "Request timed out. Please try again later.",
                    requests.exceptions.ConnectionError: f"Error connecting to server: {error}",
                    requests.exceptions.TooManyRedirects: "Too many redirects. Check your URL.",
                    requests.exceptions.InvalidURL: "Invalid URL provided.",
                    requests.exceptions.SSLError: f"SSL Error: {error}",
                    requests.exceptions.RequestException: f"Error making request: {error}",
                    AssertionError: f"Assertion error: {error}",
                }
                raise type(error)(error_mapping[type(error)]) from error
            else:
                print("Request successful")

            response = response.json()
            if not response["isValid"]:
                raise ValueError("Invalid license key")

            return response["token"]

        if bearer:
            self.bearer = bearer
        else:
            self.bearer = _authorize(self)
        self.auth_header = {"Authorization": "Bearer " + self.bearer}

    def _create_temp_files(
        self,
        file_contents: list[str],
        file_key: str,
        file_type=V_SV_FILE,
        file_prefix: str = "sv_file_",
        file_extension: str = ".sv",
    ) -> Tuple[List[str], List[Any]]:
        temp_file_names = []
        file_handles = []

        for file_content in file_contents:
            try:
                with tempfile.NamedTemporaryFile(
                    mode="w", delete=False, prefix=file_prefix, suffix=file_extension
                ) as temp_file:
                    temp_file.write(file_content)
                    temp_file_names.append(temp_file.name)

                # note that this files is opened here and will be closed later in a cleanup function
                fr = open(temp_file.name, "r")
                file_basename = os.path.basename(temp_file.name)
                file_handles.append((file_key, (file_basename, fr, file_type)))

            except (
                IOError,
                PermissionError,
                FileNotFoundError,
                TypeError,
                OSError,
            ) as error:
                print(
                    "Error writing to temporary file {}: {}".format(
                        temp_file.name, error
                    )
                )

        return temp_file_names, file_handles

    def _make_request(self, url, headers, files=None, data=None, json=None):
        response: requests.Response = None
        try:
            response = requests.post(
                url, headers=headers, files=files, data=data, json=json
            )
            response.raise_for_status()
        except (
            requests.exceptions.HTTPError,  # For HTTP errors (4xx and 5xx status codes)
            requests.exceptions.Timeout,  # If the request times out
            requests.exceptions.ConnectionError,  # If a connection to the server cannot be established
            requests.exceptions.TooManyRedirects,  # If the request exceeds the configured number of maximum redirections
            requests.exceptions.InvalidURL,  # If the URL provided is invalid
            requests.exceptions.SSLError,  # For SSL/TLS errors during an HTTPS request
            # SSL/TLS issues can include certificate verification failures,
            # expired certificates, hostname mismatches, or using outdated or insecure SSL/TLS protocols
            requests.exceptions.RequestException,  # General request exception
            AssertionError,  # Custom conditions leading to assertion errors
        ) as req_err:
            response_status_code = response.status_code if response else "N/A"
            response_text = response.text if response else "N/A"

            raise RuntimeError(
                f"{req_err.__class__.__name__} occurred while making request to {url}: {req_err}\n"
                f"Response status code: {response_status_code}\n"
                f"Response text: {response_text}"
            ) from req_err
        except Exception as err:  # For other errors
            raise RuntimeError(f"An error occurred: {err}") from err

        try:
            json_data = response.json()
            return json_data
        except json.JSONDecodeError as json_err:
            raise RuntimeError(
                f"Error decoding JSON: {json_err}\nResponse text: {response.text}"
            ) from json_err
        except Exception as err:  # For other errors
            raise RuntimeError(f"An error occurred: {err}") from err

    def _cleanup_temp_files(self, file_list, temp_file_names):
        for temp_file in file_list:
            temp_file[1][1].close()

        for temp_file in temp_file_names:
            if temp_file and os.path.exists(temp_file):
                os.remove(temp_file)

    def _cleanup_temp_file(self, temp_file, temp_file_name):
        # Close the file handle if it is open
        if temp_file and temp_file[1][1]:
            temp_file[1][1].close()

        # Remove the temp file if it exists
        if temp_file_name and os.path.exists(temp_file_name):
            os.remove(temp_file_name)

    def parse_design(self, top_file: TextIO, dependency_files: List[TextIO]):
        """
        Parses a given top RTL file and dependencies to extract and return module name, clocks, resets, params, etc. in a JSON format.

        Args:
            top_rtl_file (str): The content of the top RTL file.
            dependencies (list, optional): The content of other RTL files. Defaults to an empty list.

        Returns:
            dict: The parsed design information in JSON format.
        """
        url = self.chipstack_python_server + EDA_ENDPOINTS_PREFIX + PARSE_ENDPOINT
        files_to_send = [("topRtlFile", top_file)] + [
            ("dependentRtlFiles", dep_file) for dep_file in dependency_files
        ]
        response_dict = self._make_request(url, self.auth_header, files=files_to_send)
        return response_dict

    @deprecated_argument("rtl_file_contents", "Use 'top_file' instead.")
    def generate_mental_model(
        self,
        parsed_design: dict,
        top_file: Optional[TextIO] = None,
        rtl_file_content: str = "",
        unit_test_flow: str = "Formal",
    ) -> dict:
        """
        Generates Mental model for a given RTL file content and test plan type.

        Args:
            top_file (TextIO): The top RTL file.
            parsed_design (dict): The parsed format of the top RTL file and its dependencies in JSON format.
            unit_test_flow (str, optional): The type of test plan to be generated. Defaults to "Formal".
            rtl_file_content (str, optional): The content of the RTL file. Defaults to an empty string.

        Raises:
            ValueError: If the unit_test_flow is "Simulation".
            ValueError: If the unit_test_flow is invalid.

        Returns:
            dict: The generated unit test scenarios in JSON format.
        """
        if unit_test_flow == "Simulation":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + GENERATE_MENTAL_MODEL_ENDPOINT
            )
        elif unit_test_flow == "Formal":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + GENERATE_MENTAL_MODEL_ENDPOINT
            )
        else:
            raise ValueError("Invalid test type")

        if rtl_file_content.strip() != "":
            files_to_send: List[Any] = []
            temp_file_names, files_to_send = self._create_temp_files(
                [rtl_file_content],
                "topRtlFile",
                "application/octet-stream",
                file_prefix="dut_top_rtl_file_",
            )
        else:
            files_to_send = [("topRtlFile", top_file)]
        # Prepare the multipart/form-data body
        payload = {
            "dutParsedModel": json.dumps(parsed_design),
        }
        response_dict = self._make_request(
            url, self.auth_header, data=payload, files=files_to_send
        )

        if rtl_file_content.strip() != "":
            self._cleanup_temp_files(
                files_to_send,
                temp_file_names,
            )

        return response_dict

    def generate_functional_coverage_scenarios(
        self, mental_model: dict, unit_test_flow: str = "Formal"
    ) -> list:

        if unit_test_flow == "Simulation":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + GENERATE_SIMULATION_FUNCTIONAL_COVERAGE_SCENARIO_ENDPOINT
            )
        elif unit_test_flow == "Formal":
            raise ValueError("Functional coverage is not supported for formal flow.")
        else:
            raise ValueError("Invalid test type")
        payload = {
            "mentalModel": mental_model,
        }
        response = self._make_request(url, self.auth_header, json=payload)
        return response

    def generate_functional_coverage(
        self,
        mental_model: dict,
        scenarios: list,
        parsed_design: dict,
        unit_test_flow: str = "Simulation",
    ) -> list:

        if unit_test_flow == "Simulation":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + GENERATE_SIMULATION_FUNCTIONAL_COVERAGE_CODE_ENDPOINT
            )
        elif unit_test_flow == "Formal":
            raise ValueError("Functional coverage is not supported for formal flow.")
        else:
            raise ValueError("Invalid test plan type")

        # Prepare the multipart/form-data body
        payload = {
            "mentalModel": mental_model,
            "dutParsedModel": parsed_design,
            "scenarios": scenarios,
        }
        response = self._make_request(url, self.auth_header, json=payload)
        return response

    def generate_unit_test_scenarios(
        self,
        mental_model: dict,
        rtl_file_contents: str = "",
        unit_test_flow: str = "Formal",
    ) -> list:
        """
        Generates unit test scenarios for a given RTL file content and test plan type.

        Args:
            mental_model (str): The mental model of the RTL file.
            unit_test_flow (str, optional): The type of test plan to be generated. Defaults to "Formal".

        Raises:
            ValueError: If the unit_test_flow is "Simulation".
            ValueError: If the unit_test_flow is invalid.

        Returns:
            dict: The generated unit test scenarios.

        """
        payload: Dict[str, Any] = {
            "mentalModel": mental_model,
        }
        if unit_test_flow == "Simulation":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + GENERATE_SIMULATION_UNIT_TEST_SCENARIO_ENDPOINT
            )
        elif unit_test_flow == "Formal":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + GENERATE_FORMAL_UNIT_TEST_SCENARIO_ENDPOINT
            )
            payload["dutRtlFile"] = rtl_file_contents
        else:
            raise ValueError("Invalid test type")
        response_dict = self._make_request(url, self.auth_header, json=payload)
        return response_dict

    def generate_unit_tests(
        self,
        mental_model: dict,
        scenarios: list,
        parsed_design: dict,
        rtl_file_contents: str = "",
        unit_test_flow: str = "Formal",
    ) -> dict:
        """
        Generates unit tests for a design provided its parsed design, mental model, and scenarions

        Args:
            mental_model (str): The mental_model of the design.
            scenarios (list): The scenarios generated for the design.
            parsed_design (dict): The parsed format of the top RTL file and its dependencies in JSON format.
            unit_test_flow (str, optional): The type of test plan to be generated. Defaults to "Formal".

        Raises:
            ValueError: If the unit_test_flow is "Simulation".
            ValueError: If the unit_test_flow is invalid.

        Returns:
            dict: The generated unit test monitor with other info.
        """
        # Prepare the multipart/form-data body
        payload = {
            "mentalModel": mental_model,
            "dutParsedModel": parsed_design,
            "scenarios": scenarios,
        }
        if unit_test_flow == "Simulation":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + GENERATE_SIMULATION_UNIT_TEST_ENDPOINT
            )
        elif unit_test_flow == "Formal":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + GENERATE_FORMAL_UNIT_TEST_ENDPOINT
            )
            payload["dutRtlFile"] = rtl_file_contents
        else:
            raise ValueError("Invalid test plan type")

        response = self._make_request(url, self.auth_header, json=payload)
        return response

    def fix_syntax_of_unit_tests(
        self,
        dut_parsed_model: dict,
        mental_model: dict,
        correction_contexts: list[dict],
        unit_test_flow: str = "Formal",
    ) -> dict:
        """
        Correct unit tests for a design provided the generated testbench and parsed design.

        Args:
            mental_model (str): The mental_model of the design.
            dut_parsed_model (dict): The parsed format of the top RTL file and its dependencies in JSON format.
            correction_contexts (list): The list of correction contexts.
            unit_test_flow (str, optional): The type of test plan to be generated. Defaults to "Formal".

        Raises:
            ValueError: If the unit_test_flow is "Simulation".
            ValueError: If the unit_test_flow is invalid.

        Returns:
            dict: The corrected testbench
        """
        if unit_test_flow == "Simulation":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + FIX_SIMULATION_SYNTAX_ENDPOINT
            )
        elif unit_test_flow == "Formal":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + FIX_FORMAL_SYNTAX_ENDPOINT
            )
        else:
            raise ValueError("Invalid test plan type")

        # Prepare the multipart/form-data body
        payload = {
            "mentalModel": mental_model,
            "dutParsedModel": dut_parsed_model,
            "correctionContexts": correction_contexts,
        }
        response = self._make_request(url, self.auth_header, json=payload)
        return response

    def compose_formal_unit_tests(
        self, codeblocks: list[str], dut_parsed_model: dict
    ) -> dict:
        """
        Composes the formal unit tests for the given submodule codes.

        Args:
            codeblocks (list): The content of the submodule codes.
            dut_parsed_model (dict): The parsed format of the top RTL file and its dependencies in JSON format.

        Returns:
            dict:
                "code": The composed formal unit test code.
        """
        url = (
            self.chipstack_python_server
            + ENGINE_ENDPOINTS_PREFIX
            + COMPOSE_FORMAL_UNIT_TEST_ENDPOINT
        )
        payload = {
            "dutParsedModel": dut_parsed_model,
            "codeblocks": codeblocks,
        }

        response_dict = self._make_request(
            url,
            self.auth_header,
            json=payload,
        )
        return response_dict

    def compose_simulation_unit_tests(
        self, tasks: list[str], modules: list[str], dut_parsed_model: dict
    ) -> dict:

        url = (
            self.chipstack_python_server
            + ENGINE_ENDPOINTS_PREFIX
            + COMPOSE_SIMULATION_UNIT_TEST_ENDPOINT
        )
        payload = {
            "dutParsedModel": dut_parsed_model,
            "tasks": tasks,
            "modules": modules,
        }

        response_dict = self._make_request(
            url,
            self.auth_header,
            json=payload,
        )
        return response_dict

    def decompose_unit_tests(
        self, code: str, unit_test_flow: str = "Formal", dut_parsed_model: dict = {}
    ):
        """
        Decomposes the formal unit tests for the given code.

        Args:
            code (str): The content of the formal unit test code.

        Returns:
            dict:
                "submoduleCodes": The decomposed submodule codes list.
        """
        payload: dict | str
        payload = {
            "dutParsedModel": dut_parsed_model,
            "code": code,
        }
        if unit_test_flow == "Simulation":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + DECOMPOSE_SIMULATION_UNIT_TEST_ENDPOINT
            )
        elif unit_test_flow == "Formal":
            url = (
                self.chipstack_python_server
                + ENGINE_ENDPOINTS_PREFIX
                + DECOMPOSE_FORMAL_UNIT_TEST_ENDPOINT
            )
        else:
            raise ValueError(
                f"Invalid unit test flow: {unit_test_flow}. Must be 'Formal' or 'Simulation'"
            )

        response_dict = self._make_request(
            url,
            self.auth_header,
            json=payload,
        )
        return response_dict

    def call_jasper_endpoint(
        self,
        module_name: str,
        clocks: list[str],
        resets: list[str],
        dut_files: List[TextIO],
        sva_files: List[TextIO],
        url: str,
    ):
        # push the files to the temp folder
        dut_files_to_send = [("dut_files", file) for file in dut_files]
        monitor_files_to_send = [("sva_files", file) for file in sva_files]
        payload = {
            "jasper_config": json.dumps(
                {
                    "top_module": module_name,
                    "clocks": clocks,
                    "resets": resets,
                }
            )
        }

        response_dict = self._make_request(
            url,
            self.auth_header,
            files=dut_files_to_send + monitor_files_to_send,
            data=payload,
        )

        return response_dict

    def slang_compile_check(
        self,
        top_module: str,
        files: List[TextIO],
    ):
        """
        Checks the syntax of the given RTL files and SVA files using Slang.

        Args:
            file_contents (list): The content of the RTL and SVA files.

        Returns:
            dict: The response from the Slang syntax check.
        """
        url = (
            self.chipstack_python_server
            + EDA_ENDPOINTS_PREFIX
            + COMPILE_CHECK_SLANG_ENDPOINT
        )

        payload = {
            "slang_config": json.dumps(
                {
                    "top_module": top_module,
                }
            )
        }

        # temp_file_names, file_list = self._create_temp_files(file_contents, "files")
        files_to_send = [("files", file) for file in files]
        response_dict = self._make_request(
            url,
            self.auth_header,
            files=files_to_send,
            data=payload,
        )
        return response_dict

    def jasper_syntax_check(
        self,
        module_name: str,
        clocks: list[str],
        resets: list[str],
        dut_files: List[TextIO],
        sva_files: List[TextIO],
    ):
        """
        Checks the syntax of the given RTL files and SVA files using Jasper.

        Args:
            module_name (str): The name of the module.
            clocks (list): The list of clock signals.
            resets (list): The list of reset signals.
            dut_files (list): The DUT RTL files.
            sva_files (list): The SVA files.

        Returns:
            dict: The response from the Jasper syntax check.
        """
        url = (
            self.chipstack_python_server
            + EDA_ENDPOINTS_PREFIX
            + COMPILE_CHECK_JASPER_ENDPOINT
        )
        return self.call_jasper_endpoint(
            module_name=module_name,
            clocks=clocks,
            resets=resets,
            dut_files=dut_files,
            sva_files=sva_files,
            url=url,
        )

    def simulation_syntax_check(
        self,
        sva_files: List[TextIO],
    ) -> dict:
        """
        Perform syntax check for simulation files.
        Args:
            sva_files (List[TextIO]): List of file descriptors.
        Returns:
            dict: Response dictionary containing the result of the syntax check.
        """

        url = self.chipstack_eda_server + COMPILE_CHECK_SIMULATION_ENDPOINT
        files_to_send = [("files", file) for file in sva_files]
        response = self._make_request(
            url,
            self.auth_header,
            files=files_to_send,
        )
        return response

    def run_formal_tests(
        self,
        module_name: str,
        clocks: list[str],
        resets: list[str],
        dut_files: List[TextIO],
        sva_files: List[TextIO],
    ):
        """
        Parses a given top RTL file and dependencies to extract and return module name, clocks, resets, params, etc. in a JSON format.

        Args:
            module_name (str): The name of the module.
            clocks (list): The list of clock signals.
            resets (list): The list of reset signals.
            dut_files (list): The content of the DUT RTL files.
            sva_files (list): The content of the SVA files.

        Returns:
            dict: The parsed design information in JSON format.
        """
        url = self.chipstack_eda_server + INVOKE_JASPER_ENDPOINT
        return self.call_jasper_endpoint(
            module_name=module_name,
            clocks=clocks,
            resets=resets,
            dut_files=dut_files,
            sva_files=sva_files,
            url=url,
        )

    def run_simulation_tests(
        self, dut_files: List[TextIO], testbench_files: List[TextIO]
    ):
        url = self.chipstack_eda_server + INVOKE_XCELIUM_ENDPOINT
        files_to_send = [("files", file) for file in dut_files + testbench_files]
        response_dict = self._make_request(
            url,
            self.auth_header,
            files=files_to_send,
        )
        return response_dict
