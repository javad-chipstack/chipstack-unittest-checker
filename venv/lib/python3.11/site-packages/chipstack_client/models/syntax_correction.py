from typing import List
from pydantic import BaseModel

from chipstack_client.utils.reporting import indent_multiline_string


class SyntaxCorrectionHistoryCodeBlock(BaseModel):
    """A class that stores the history of syntax correction for one code block."""

    input_code: str  # The original code block
    errors: list[str] = []
    warnings: list[str] = []
    fixed_code: str = ""  # Code block after fixing syntax issues
    is_syntax_clean: bool = False  # True if the code block has no syntax issues

    def get_num_errors(self) -> int:
        """Get the number of errors in the code block."""
        return len(self.errors) + len(self.warnings)

    def dump_metadata(self) -> dict:
        """Dump the metadata of the code block."""
        return {
            "input_code": self.input_code,
            "errors": self.errors,
            "warnings": self.warnings,
            "fixed_code": self.fixed_code,
        }


class SyntaxCorrectionCodeBlock(BaseModel):
    """A class that stores the intermediate results of syntax correction for one code block and provides utility functions."""

    correction_history: list[SyntaxCorrectionHistoryCodeBlock] = []
    # define a lambda that looks at is_syntax_clean of the last element in correction_history
    is_syntax_clean: bool = False

    def get_latest_uncorrected_code(self) -> str:
        """Get the latest uncorrected code block."""
        return self.correction_history[-1].input_code

    def get_latest_corrected_code(self) -> str:
        """Get the latest correction for the code block."""
        return self.correction_history[-1].fixed_code

    def update_latest_correction_result(
        self, errors: list[str], warnings: list[str]
    ) -> None:
        """Update the correction result for the code block."""
        latest_correction = self.correction_history[-1]
        latest_correction.errors = errors
        latest_correction.warnings = warnings
        latest_correction.is_syntax_clean = not (errors or warnings)

    def add_fixed_code_to_latest_correction(self, fixed_code: str) -> None:
        """Update the latest correction for the code block to add the fixed code."""
        latest_correction = self.correction_history[-1]
        latest_correction.fixed_code = fixed_code

    def add_new_correction(self, input_code: str) -> None:
        """Adds a new round of correction to the code block. This involves adding a new SyntaxCorrectionHistoryCodeBlock to the correction_history."""
        self.correction_history.append(
            SyntaxCorrectionHistoryCodeBlock(input_code=input_code)
        )

    def dump_metadata(self) -> dict:
        """Dump the metadata of the code block."""
        return {
            "correction_history": [
                correction.dump_metadata() for correction in self.correction_history
            ],
            "is_syntax_clean": self.is_syntax_clean,
        }


class SyntaxCorrection:
    """A class that stores the intermediate results of syntax correction for a set of code blocks and provides utility functions."""

    def __init__(self, codeblocks: list[str]) -> None:
        self.codeblocks: list[SyntaxCorrectionCodeBlock] = []
        self.add_codeblocks(codeblocks)

    def add_codeblocks(self, codeblocks: list[str]) -> None:
        """Bulk add codeblocks to the SyntaxCorrection object."""
        for codeblock in codeblocks:
            self.codeblocks.append(
                SyntaxCorrectionCodeBlock(
                    correction_history=[
                        SyntaxCorrectionHistoryCodeBlock(
                            input_code=codeblock, fixed_code=codeblock
                        )
                    ]
                )
            )

    def dump_metadata(self) -> list[dict]:
        """Dump the metadata of the code blocks."""
        return [codeblock.dump_metadata() for codeblock in self.codeblocks]


# NOTE: Potentially deprecated code below: Javad to confirm


class SyntaxIssues(BaseModel):
    errors: List[str] = []
    warnings: List[str] = []
    full_logs: str = ""

    def __bool__(self):
        return bool(self.errors or self.warnings)

    def __str__(self):
        if self.errors:
            errors_str = indent_multiline_string("\n".join(self.errors))
        else:
            errors_str = indent_multiline_string("None")

        if self.warnings:
            warnings_str = indent_multiline_string("\n".join(self.warnings))
        else:
            warnings_str = indent_multiline_string("None")

        result = f"""Errors: \n{
                errors_str
            }\nWarnings: \n{
                warnings_str
            }"""
        return result


class CorrectionContext(BaseModel):
    code: str
    syntax_issues: SyntaxIssues
