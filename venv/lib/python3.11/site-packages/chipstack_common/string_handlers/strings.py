import html
import sys
import re
import hashlib
import random
import string
import uuid
from datetime import datetime
from typing import List
import chipstack_common.svutils.regex as regex_patterns


def text_to_html(text):
    """
    Converts plain text to HTML format.
    Args:
        text (str): The plain text to be converted.
    Returns:
        str: The HTML formatted text.
    """
    sanitized_text = html.escape(text)
    html_output = (
        sanitized_text.replace("\n", "<br>")
        .replace(" ", "&nbsp;")
        .replace("\t", "&emsp;")
    )
    return html_output


def indent_multiline_string(
    text: str, number_of_spaces=4, exclude_first_line=False
) -> str:
    """Indent all lines of a multiline string by the specified number of spaces."""
    lines = text.split("\n")
    for idx, line in enumerate(lines):
        if idx == 0 and exclude_first_line:
            continue
        lines[idx] = (number_of_spaces * " ") + line
    return "\n".join(lines)


def remove_leading_empty_lines(code_block: str) -> str:
    """
    Removes leading empty lines from a given code block.
    Args:
        code_block (str): The code block to remove leading empty lines from.
    Returns:
        str: The code block with leading empty lines removed.
    """
    lines = code_block.split("\n")
    first = 0
    for i, line in enumerate(lines):
        if line.strip():
            first = i
            break

    return "\n".join(lines[first:])


def remove_trailing_empty_lines(code_block: str) -> str:
    """
    Removes trailing empty lines from a code block.

    Args:
        code_block (str): The code block to remove trailing empty lines from.

    Returns:
        str: The code block with trailing empty lines removed.
    """
    lines = code_block.split("\n")

    last = len(lines)
    for i, line in enumerate(reversed(lines)):
        if line.strip():
            last = len(lines) - i
            break

    return "\n".join(lines[:last])


def generate_valid_identifier(text: str) -> str:
    # Replace invalid characters with underscores
    name = re.sub(regex_patterns.VARIABLE_INVALID_CHARS_REGEX, "_", text)

    if (len(name) == 0) or (name.strip() == ""):
        name = "_"

    # Ensure the name doesn't start with a number
    if name[0].isdigit():
        name = "_" + name

    return name


def unindent_multiline_string(text) -> str:
    """
    Removes the common indentation from a multiline string.
    """
    lines = text.split("\n")
    # Remove empty lines
    lines = [line for line in lines if line.strip()]
    # Find the minimum indentation
    min_indent = sys.maxsize
    for line in lines:
        stripped = line.lstrip()
        indent = len(line) - len(stripped)
        min_indent = min(min_indent, indent)

    unindented_lines = [line[min_indent:] for line in lines]
    unindented_text = "\n".join(unindented_lines)

    return unindented_text

def get_sha1_hash(to_hash: str) -> str:
    """
    Returns the SHA1 hash of a string.

    Args:
        to_hash (str): The input string.

    Returns:
        str: The SHA1 hash of the input string.
    """
    sha1_hash = hashlib.sha1(to_hash.encode()).hexdigest()
    return sha1_hash

def get_random_character_id(length: int = 8) -> str:
    """
    Returns a random character ID of the specified length.

    Args:
        length (int): The length of the character ID. Defaults to 8.

    Returns:
        str: A random character ID.
    """

    return "".join(random.choices(string.ascii_uppercase + string.digits, k=length))

def get_current_datetime() -> str:
    """
    Generates the current date and time in the format of YYYY_MM_DD_HH_mm_SS.

    Returns:
        str: The current date and time.
    """
    return datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

def get_unique_codeblock_names(cur_names: List[str]) -> List[str]:
    seen = dict()
    result_names: List[str] = []
    for name in cur_names:
        if name not in seen:
            seen[name] = 1
        else:
            seen[name] += 1

    for name in cur_names:
        if seen[name] == 1:
            result_names.append(name)
        else:
            unique_id = get_uuid_string()
            new_name = f"{name}_{unique_id[:4]}"

            while new_name in seen:
                unique_id = get_uuid_string()
                new_name = f"{name}_{unique_id[:4]}"

            seen[new_name] = 1
            result_names.append(new_name)
    return result_names

def get_uuid_string() -> str:
    return str(uuid.uuid4())


def is_whole_word_in_string(word, string) -> bool:
    """
    Check if a whole word is present in a string.
    Returns True if the whole word is found, False otherwise.
    """
    pattern = r"\b" + re.escape(word) + r"\b"
    return re.search(pattern, string) is not None