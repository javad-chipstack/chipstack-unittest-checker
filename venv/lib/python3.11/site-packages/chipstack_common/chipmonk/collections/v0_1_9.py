import logging
import re

from chipstack_common.chipmonk.catalog import task_collection
from chipstack_common.chipmonk.collection_library import (
    ChipmonkRound,
    ChipmonkTask,
    ChipmonkTaskCollection,
)
from chipstack_common.chipmonk.prompt_library import render_prompt_template
from chipstack_common.chipmonk.utils.scenario_group import ScenarioGroup
from chipstack_common.chipmonk.utils.parsing import (
    ScenarioParseOptions,
    SvaParseOptions,
    try_parse_scenarios,
    try_parse_sva,
)
from chipstack_common.chipmonk.utils.rounds import rounds
from chipstack_common.llm.config import InferenceOptions, ModelSelection
from chipstack_common.llm.models import ProviderIdentifier
from chipstack_common.string_handlers.llm_response import (
    remove_backtick_block,
    standardize_code,
)
from dataclasses import dataclass
from langchain_core.messages import HumanMessage
from typing import List, Optional


_MODEL_SELECTION = ModelSelection(
    provider=ProviderIdentifier.TEXT_GENERATION_INFERENCE,
    model="chipstack/ift-mistral-7b-instruct-v0-2-t7fr2p",
    model_base_url="http://34.124.199.254:8001/v1",
)


CHIPMONK_VERSION = "0.1.9"


@dataclass(frozen=True)
class GetSvaForScenarios_0_1_9(ChipmonkTask[List[str]]):
    """
    Implements GetSvaForScenarios for version 0.1.9 of the Chipmonk model.

    This consists of multiple rounds of interaction with the LLM, one per scenario.
    """

    file_contents: str
    scenarios: List[str]

    _INFERENCE_OPTIONS = InferenceOptions(
        temperature=0.3,
        max_tokens=2048,
        top_p=0.2,
    )

    _TEMPLATE = "0_1_9_get_sva_for_scenarios"

    def task_rounds(self) -> List[ChipmonkRound]:
        return rounds(
            _MODEL_SELECTION,
            self._INFERENCE_OPTIONS,
            [
                HumanMessage(
                    content=render_prompt_template(
                        self._TEMPLATE,
                        design_code=standardize_code(self.file_contents),
                        scenario=s,
                    )
                )
                for s in self.scenarios
            ],
        )

    def parse_responses(self, raw_llm_responses: List[str]) -> Optional[List[str]]:
        return [
            try_parse_sva(
                remove_backtick_block(r),
                SvaParseOptions(strip_prior_to_assertion_comment=True),
            )
            for r in raw_llm_responses
        ]


@dataclass(frozen=True)
class GetScenarios_0_1_9(ChipmonkTask[List[str]]):
    """
    Implements GetScenarios for version 0.1.9 of the Chipmonk model.

    This consists of 3 rounds of interaction with the LLM, each of which asks for
    scenarios related to port groups.
    """

    file_contents: str
    input_ports: List[str]
    reset_ports: List[str]
    output_ports: List[str]
    internal_signals: List[str]
    logger: logging.Logger

    _INFERENCE_OPTIONS = InferenceOptions(
        temperature=0.3,
        max_tokens=2048,
        top_p=0.7,
    )

    _TEMPLATE = "0_1_9_get_scenarios"

    def task_rounds(self) -> List[ChipmonkRound]:
        return rounds(
            _MODEL_SELECTION,
            self._INFERENCE_OPTIONS,
            [
                HumanMessage(
                    content=render_prompt_template(
                        self._TEMPLATE,
                        design_code=standardize_code(self.file_contents),
                        group_wise_instruction=scenario_group.instructions(),
                        port_details=scenario_group.port_details(
                            input_ports=self.input_ports,
                            output_ports=self.output_ports,
                            reset_ports=self.reset_ports,
                        ),
                    )
                )
                for scenario_group in ScenarioGroup
                if scenario_group.instructions()
            ],
        )

    def parse_responses(self, raw_llm_responses: List[str]) -> Optional[List[str]]:
        parsed_scenarios = []
        for response in raw_llm_responses:
            parsed_scenarios.extend(
                try_parse_scenarios(
                    remove_backtick_block(response),
                    ScenarioParseOptions(
                        parse_raw_regex=False,
                        parse_as_json_list=True,
                        parse_as_single_quoted_json_list=True,
                        parse_partial_json_list=True,
                        parse_ignore_non_json_prefix=True,
                    ),
                )
            )

        scenarios_without_internal_ports = []
        for scenario in parsed_scenarios:
            ports_used = set(re.findall(r"'([^'\s]+)'", scenario))
            if len(ports_used.intersection(self.internal_signals)) == 0:
                # Only keep scenarios that don't use internal ports
                scenarios_without_internal_ports.append(scenario)
            else:
                self.logger.info(
                    f"Skipping scenario because it uses internal signals: {scenario}"
                )

        self.logger.info(f"\tFound {len(scenarios_without_internal_ports)} scenarios")

        return scenarios_without_internal_ports


_KEY_INPUT_PORTS = "inputPorts"
"""The key for input ports in the parsed design."""

_KEY_INTERNAL_SIGNALS = "internalSignals"
"""The key for internal signals in the parsed design."""

_KEY_OUTPUT_PORTS = "outputPorts"
"""The key for output ports in the parsed design."""

_KEY_PARSED_DESIGN = "parsed_design"
"""The key for the parsed design."""

_KEY_RESET_PORTS = "resetPorts"
"""The key for reset ports in the parsed design."""


@task_collection(version="0.1.9")
@dataclass(frozen=True)
class Chipmonk_0_1_9(ChipmonkTaskCollection):
    """
    Task library for version 0.1.9 of the Chipmonk model.

    Expected kwargs on init:
        None
    Optional kwargs on init:
        logger: logging.Logger
    """

    logger: logging.Logger = logging.getLogger(__name__)

    def get_scenarios(self, file_contents: str, **kwargs) -> ChipmonkTask:
        """
        Get scenarios, with internal signals removed and scenarios grouped by signal.

        Expected kwargs:
            parsed_design: dict - The parsed design file.
        """
        parsed_design_get = lambda key: kwargs.get(_KEY_PARSED_DESIGN, {}).get(key, [])
        return GetScenarios_0_1_9(
            file_contents,
            input_ports=parsed_design_get(_KEY_INPUT_PORTS),
            reset_ports=parsed_design_get(_KEY_RESET_PORTS),
            output_ports=parsed_design_get(_KEY_OUTPUT_PORTS),
            internal_signals=parsed_design_get(_KEY_INTERNAL_SIGNALS),
            logger=self.logger,
        )

    def get_sva_for_scenarios(
        self, file_contents: str, scenarios: List[str], **kwargs
    ) -> ChipmonkTask:
        return GetSvaForScenarios_0_1_9(file_contents, scenarios)
