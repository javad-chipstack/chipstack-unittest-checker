import json
import logging

from dataclasses import dataclass
from typing import List


@dataclass(frozen=True)
class ScenarioParseOptions:
    """Controls how to parse scenarios from an LLM response."""

    # Tries to parse scenarios as raw strings using a regex.
    parse_raw_regex: bool = False
    # Tries to parse scenarios as a well-formatted JSON list.
    parse_as_json_list: bool = False
    # Tries to parse scenarios from a JSON list with single quotes.
    parse_as_single_quoted_json_list: bool = False
    # Tries to parse scenarios from a JSON list that is cut off without closing tags.
    parse_partial_json_list: bool = False
    # Ignores non-JSON textual content at the beginning of the response.
    parse_ignore_non_json_prefix: bool = False

    @staticmethod
    def all() -> "ScenarioParseOptions":
        """Returns a ScenarioParseOptions object that tries all parsing options."""
        return ScenarioParseOptions(
            parse_raw_regex=True,
            parse_as_json_list=True,
            parse_as_single_quoted_json_list=True,
            parse_partial_json_list=True,
            parse_ignore_non_json_prefix=True,
        )


@dataclass(frozen=True)
class SvaParseOptions:
    """Controls how to parse SVA from an LLM response."""

    # Strips everything before the first assertion comment.
    strip_prior_to_assertion_comment: bool = False

    @staticmethod
    def all() -> "SvaParseOptions":
        """Returns a SvaParseOptions object that tries all parsing options."""
        return SvaParseOptions(
            strip_prior_to_assertion_comment=True,
        )


def parse_scenario_list(
    scenarios: List[str | dict], logger: logging.Logger
) -> List[str]:
    parsed_values = []
    for value in scenarios:
        if isinstance(value, str):
            parsed_values.append(value)
        elif isinstance(value, dict) and "scenario" in value:
            parsed_values.append(value["scenario"])
        else:
            logger.info(f"Could not parse value: {value} of type: {type(value)}")
    return parsed_values


_ASSERTION_PREFIX = "Assert"
"""The prefix with which text-only assertions may begin."""


def strip_non_json_prefix(response: str) -> str:
    """Returns a string with the non-JSON prefix removed."""
    brace_start_index = response.find("{")
    bracket_start_index = response.find("[")

    if brace_start_index == -1 and bracket_start_index == -1:
        return response

    if brace_start_index > -1 and bracket_start_index > -1:
        return response[min(brace_start_index, bracket_start_index) :]

    return response[max(brace_start_index, bracket_start_index) :]


def try_parse_scenarios(
    response: str,
    parse_options: ScenarioParseOptions = ScenarioParseOptions.all(),
    logger: logging.Logger = logging.getLogger(__name__),
) -> List[str]:
    """Tries to parse scenarios from an LLM response."""

    if parse_options.parse_raw_regex:
        # Regular expression to match sentences
        sentences = response.split("\n")
        scenarios = [
            sentence[sentence.find(_ASSERTION_PREFIX) :].strip()
            for sentence in sentences
            if _ASSERTION_PREFIX in sentence
        ]

        if len(scenarios) > 0:
            logger.info(f"Parsed {len(scenarios)} scenarios from response.")
            return [s + "." for s in scenarios]

    if parse_options.parse_ignore_non_json_prefix:
        response = strip_non_json_prefix(response)

    if parse_options.parse_as_json_list:
        try:
            obj = json.loads(response)
            if isinstance(obj, list):
                return parse_scenario_list(obj, logger)
            else:
                logger.warning("Object is not a list. Returning empty list.")
                return []
        except Exception as e:
            logger.debug(f"Cannot parse response. {repr(e)}")

    stripped_response = response.strip()

    if parse_options.parse_partial_json_list:
        if stripped_response.startswith("["):
            try:
                obj = json.loads(
                    stripped_response[: stripped_response.rfind("}") + 1] + "]"
                )
                if isinstance(obj, list):
                    return parse_scenario_list(obj, logger)
                else:
                    logger.warning("Object is not a list. Returning empty list.")
                    return []
            except Exception as e:
                logger.warning(f"Cannot parse response. {repr(e)}")
        else:
            logger.warning(
                f"Response does not start with '['. First chars: {response[:10]}"
            )

    if parse_options.parse_as_single_quoted_json_list:
        if stripped_response.startswith("['"):
            return try_parse_scenarios(
                stripped_response.replace("'", '"'),
                ScenarioParseOptions(
                    parse_as_json_list=True, parse_partial_json_list=True
                ),
            )

    logger.warning(f"Could not parse response. Returning empty list. {response}")
    return []


def try_parse_sva(
    response: str,
    parse_options: SvaParseOptions = SvaParseOptions.all(),
) -> str:
    """Tries to parse SVA from an LLM response."""
    if parse_options.strip_prior_to_assertion_comment:
        comment_index = response.find("// ")
        if comment_index > -1:
            return response[comment_index:]

    return response
