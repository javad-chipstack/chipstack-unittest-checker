import re
from typing import List
from chipstack_common.svutils.sv_parse_types import Module, ModuleParameter, ModulePort
import chipstack_common.svutils.regex as regex_patterns


def replace_instance_name(input: str, new_name: str) -> str:
    try:
        pattern = regex_patterns.INSTANCE_NAME_REGEX
        matches = re.search(pattern, input)

        if not matches:
            print("No instance name found in the input.")
            return ""

        original_instance_name = matches.group(2)
        output = re.sub(rf"\b{original_instance_name}\b", new_name, input)

        return output
    except Exception as error:
        print(f"An error occurred during the replacement: {error}")
        return ""


def remove_comments(text: str) -> str:
    comment_regex = regex_patterns.COMMENT_PATTERN
    return re.sub(comment_regex, "", text, flags=re.MULTILINE)


def get_module_interface(text: str) -> str:
    module_regex = regex_patterns.CAPTURE_MODULE_DECLARATION_REGEX
    module_interface = re.search(module_regex, text, re.MULTILINE)
    return "" if module_interface is None else module_interface.group(0)


def get_task_interface(text: str) -> str:
    task_regex = regex_patterns.TASK_DECLARATION_REGEX
    task_interface = re.search(task_regex, text, re.DOTALL)
    return "" if task_interface is None else task_interface.group(0)


def get_module_name(input_string):
    regex = regex_patterns.CAPTURE_MODULE_NAME_REGEX
    match = re.search(regex, input_string)
    return "" if match is None else match.group(1)


def get_task_name(input_string):
    regex = regex_patterns.TASK_NAME_REGEX
    match = re.search(regex, input_string)
    return "" if match is None else match.group(2)


def get_parameters(input: str) -> List[ModuleParameter]:
    parameters = {}

    module_content = re.search(
        regex_patterns.CAPTURE_MODULE_PLUS_PARAMETERS_ONLY_REGEX, input, re.DOTALL
    )
    if not module_content:
        return []
    parameters_dirty = [x.strip() for x in module_content.group(1).split(",")]

    for parameter_dirty in parameters_dirty:
        if "=" in parameter_dirty:
            parameter_key, right_side = [
                x.strip() for x in parameter_dirty.split("=", 1)
            ]
            parameters[parameter_key.split(" ")[-1]] = right_side

    return [
        ModuleParameter(name=k, type="int", kind="parameter", value=v)
        for k, v in parameters.items()
    ]


def get_ports(module_interface: str, port_type: str) -> List[ModulePort]:
    regex = regex_patterns.PORT_MATCH_REGEX.format(port_type=port_type)
    matches = re.findall(regex, module_interface) or []
    ports = []
    for match in matches:
        match = match.strip()
        port = [x.strip() for x in re.sub(r"[,;)]", " ", match).split(" ") if x.strip()]
        port_name = port[-1]
        if port_name:
            ports.append(ModulePort(name=port_name, type=" ".join(port[1:-1])))

    return ports


def generate_instantiation(module: Module) -> str:
    instantiation = f"{module.name} "

    if module.parameters:
        instantiation += " #(\n"
        entries = [p.name for p in module.parameters]
        total_entries = len(entries)

        for index, param_name in enumerate(entries):
            if index != total_entries - 1:
                instantiation += f".{param_name}({param_name}),\n"
            else:
                instantiation += f".{param_name}({param_name})\n"

        instantiation += ")"

    instantiation += f" {module.name}_inst (\n"
    for port in (
        module.clock_ports
        + module.reset_ports
        + module.input_ports
        + module.inout_ports
        + module.output_ports
    ):
        instantiation += f".{port.name}({port.name}),\n"

    instantiation = instantiation[:-2] + "\n);\n\n"
    return instantiation


def parse_parameters_from_sub_module(submodule: str) -> List[str]:
    semicolon_index = submodule.find(";")
    item = ""
    if semicolon_index != -1:
        item = submodule[:semicolon_index].strip()
    else:
        item = submodule.strip()

    match = re.search(r"#\s*\(([\s\S]*?)\)", item)
    if match:
        item = match.group(1).replace("\n", "")
    else:
        item = ""

    params = []
    for sub_item in item.split(","):
        match = re.search(r"([^=]+)=", sub_item)
        if match:
            param = match.group(1).strip().split(" ").pop()
            params.append(param if param else "")
        else:
            params.append("")

    return [param for param in params if param.strip() != ""]


def get_all_modules_list(submodules: str) -> List[Module]:
    # include module name in the split
    clean_submodules = remove_comments(submodules)
    module_blocks = re.findall(
        regex_patterns.MODULE_BLOCK_REGEX, clean_submodules, flags=re.DOTALL
    )
    module_blocks = [block for block in module_blocks if block != ""]

    return [parse_code_into_module(module_block) for module_block in module_blocks]


def generate_dotstar_instantiation(submodules_code: List[str]) -> List[str]:
    instantiations = []
    for submodule_code in submodules_code:
        submodule = parse_code_into_module(submodule_code)
        params = ""
        if len(submodule.parameters) > 0:
            arr = []
            for param in submodule.parameters:
                arr.append(f".{param.name}({param.name})")
            params += f"#({', '.join(arr)})"
        instantiations.append(f"{submodule.name} {params} {submodule.name}_inst(.*);")
    return instantiations


def parse_code_into_module(code: str) -> Module:
    name = ""
    parameters = []
    inputs = []
    inouts = []
    outputs = []
    try:
        code = remove_comments(code)
        instantiation = get_module_interface(code)
        # instantiation is none only if no module is found
        # in other sources of error an exception is raised
        if instantiation is None:
            return Module(
                name="",
                parameters=[],
                input_ports=[],
                inout_ports=[],
                output_ports=[],
                instance="",
                interfaces=[],
            )
        name = get_module_name(instantiation)
        parameters = get_parameters(instantiation)
        inputs = get_ports(instantiation, "input")
        inouts = get_ports(instantiation, "inout")
        outputs = get_ports(instantiation, "output")
    except Exception as error:
        raise Exception(f"Error extracting module info: {error}")

    module = Module(
        name=name,
        parameters=parameters,
        input_ports=inputs,
        inout_ports=inouts,
        output_ports=outputs,
        instance="",
        interfaces=[],
    )

    module.instance = generate_instantiation(module)
    return module

def split_into_modules(code: str) -> List[str]:
    """
    Splits the given code into individual modules.
    Return a list of strings, where each string represents an individual module.
    """
    modules = re.findall(regex_patterns.MODULE_BLOCK_REGEX, code, re.DOTALL)
    return modules
