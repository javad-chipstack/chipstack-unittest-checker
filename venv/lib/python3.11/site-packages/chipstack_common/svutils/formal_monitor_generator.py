from abc import abstractmethod
import re
from typing import List, Any
from pydantic import BaseModel
import chipstack_common.svutils.regex as regex_patterns
from chipstack_common.svutils.sv_parse_types import Module, ScenarioDetail
from chipstack_common.svutils.sv_monitor_generate import (
    generate_module_declaration,
    generate_monitor_module_bind_statement,
    remove_module_declaration_and_endmodule,
    remove_includes,
    generate_submodule_model,
    convert_module_to_monitor,
)
from chipstack_common.svutils.sv_parser import (
    generate_dotstar_instantiation,
    get_module_name,
    remove_comments,
)
from chipstack_common.string_handlers.llm_response import (
    remove_code_formatting,
)

INSTANCE_NAME_DUT = "dut"
MONITOR_SUFFIX_NAME = "_monitor"
DEFAULT_MODULE_NAME = "DEFAULT_NAME"


class StructuredCode(BaseModel):
    name: str

    @abstractmethod
    def to_code(self) -> str:
        return ""


class BaseTestCase(StructuredCode):
    scenario: ScenarioDetail = ScenarioDetail(name="", description="")


class FormalTestCase(BaseTestCase):
    declaration: str
    body_code: str = ""

    def __init__(
        self,
        declaration: str,
        body_code: str,
        **data: Any,
    ):
        super().__init__(
            declaration=declaration,
            body_code=remove_module_declaration_and_endmodule(
                remove_code_formatting(body_code)
            ),
            **data,
        )

    def to_code(self) -> str:
        module_code = f"""{
            self.declaration
        }\n{
            self.body_code
        }\nendmodule\n\n"""

        module_code = module_code.replace("\n\n\n\n", "\n")
        return remove_code_formatting(module_code)

    @staticmethod
    def from_code(code: str, dut_parsed_model: Module, name: str) -> "FormalTestCase":
        body_code = remove_code_formatting(
            remove_module_declaration_and_endmodule(code)
        )
        body_code = remove_includes(body_code)
        module = generate_submodule_model(
            name=name,
            code=remove_comments(body_code),
            dut_top_module=dut_parsed_model,
        )
        monitor_module = convert_module_to_monitor(module, monitor_name=name)
        declaration = generate_module_declaration(monitor_module)
        return FormalTestCase(name=name, declaration=declaration, body_code=body_code)


def uniquify_block_names(modules: List[FormalTestCase]) -> None:
    unique_module_names = {}
    for module in modules:
        if module.name == "":
            continue
        if module.name not in unique_module_names:
            unique_module_names[module.name] = 1
        else:
            unique_module_names[module.name] += 1
            new_index = unique_module_names[module.name]
            unique_module_name = f"{module.name}_{new_index}"
            prev_name = module.name
            module.declaration = re.sub(
                rf"\b{prev_name}\b",
                unique_module_name,
                module.declaration,
            )
            module.name = unique_module_name


class FormalCode(StructuredCode):
    dut_module: Module
    test_cases: List[FormalTestCase]

    def to_code(self) -> str:
        modules_to_convert = self.test_cases
        uniquify_block_names(modules_to_convert)
        unique_name_submodules_code_list = [
            module.to_code()
            for module in modules_to_convert
            if (module.name.strip() != "") and (module.body_code.strip() != "")
        ]
        unique_name_submodules_code = "\n\n".join(unique_name_submodules_code_list)

        unique_name_instantiations = generate_dotstar_instantiation(
            unique_name_submodules_code_list
        )
        unique_name_instantiations_code = "\n".join(unique_name_instantiations)

        monitor_module = convert_module_to_monitor(
            self.dut_module, monitor_name=self.dut_module.name + MONITOR_SUFFIX_NAME
        )
        monitor_declaration_code = generate_module_declaration(monitor_module)
        bind_statement_code = generate_monitor_module_bind_statement(
            module=self.dut_module, monitor=monitor_module
        )

        monitor_code = f"""{
            monitor_declaration_code
        }\n{
            unique_name_instantiations_code
        }\nendmodule\n\n{
            unique_name_submodules_code
        }\n{
            bind_statement_code
        }"""

        return remove_code_formatting(monitor_code)

    @staticmethod
    def from_codeblocks(
        codeblocks: List[str], dut_parsed_model: Module
    ) -> "FormalCode":
        return FormalCode(
            name=dut_parsed_model.name + MONITOR_SUFFIX_NAME,
            dut_module=dut_parsed_model,
            test_cases=[
                FormalTestCase.from_code(
                    code=codeblock,
                    dut_parsed_model=dut_parsed_model,
                    name=get_module_name(codeblock),
                )
                for codeblock in codeblocks
            ],
        )

    @staticmethod
    def parse_into_codeblocks(code: str) -> List[str]:
        all_modules = re.findall(regex_patterns.MODULE_BLOCK_REGEX, code, re.DOTALL)
        # top_module = all_modules[0]
        submodules = all_modules[1:]
        return submodules
