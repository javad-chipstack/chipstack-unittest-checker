"""
This module contains enums representing different models used for parsing.
"""

from typing import List, Optional, Tuple, Dict
from pydantic import BaseModel, ConfigDict
from pydantic.alias_generators import to_camel
from pydantic import BaseModel, model_validator
import json

from langchain_core.output_parsers import JsonOutputParser
from chipstack_common.string_handlers.llm_response import remove_code_formatting

# Verilog/SystemVerilog code block types
INDENT_2_SPACE: str = " " * 2
INDENT_4_SPACE: str = " " * 4
INDENT_6_SPACE: str = " " * 6
INDENT_8_SPACE: str = " " * 8
INDENT_4_SPACE_INT: int = 4
INDENT_8_SPACE_INT: int = 8


class JSONValidatedBaseModel(BaseModel):
    """
    Base class for pydantic models that require json validation in requests.
    """

    @model_validator(mode="before")
    @classmethod
    def validate_to_json(cls, value) -> "JSONValidatedBaseModel":
        if isinstance(value, str):
            return cls(**json.loads(value))
        return value


class ModuleParameter(BaseModel):
    name: str
    type: str
    kind: str
    value: str

    @staticmethod
    def module_param_details_template() -> str:
        return f"""
"format": 
{ModuleParameter(
    name = "Name of the parameter", type = "type of parameter (e.g. int, logic)", kind="parameter", value="value of parameter as string (if value is integer, provide in string format)"
).model_dump_json(indent=INDENT_4_SPACE_INT)}
"""

    @staticmethod
    def from_json_resp(resp_str: str) -> List["ModuleParameter"]:
        try:
            response = remove_code_formatting(resp_str)
            paraminfo_dict = JsonOutputParser(pydantic_object=ModuleParameter).parse(
                response
            )
            if isinstance(paraminfo_dict, dict):
                paraminfo_dict = [paraminfo_dict]
            return [ModuleParameter(**item) for item in paraminfo_dict]
        except Exception as e:
            print(f"cannot generate port parameters: {e}")
            return []


class ModulePort(BaseModel):
    name: str
    type: str


class ModuleInterface(BaseModel):
    name: str
    instance: str
    modport: str
    input_ports: List[ModulePort]
    output_ports: List[ModulePort]


class ClockReset(BaseModel):
    clock: List[str]
    reset: List[str]


class Clock(BaseModel):
    name: str
    type: str

    @staticmethod
    def module_clock_template() -> str:
        return f"""
"format": 
{Clock(
    name = "Name of clock signal", type = "type of clock signal (e.g. wire, logic)"
).model_dump_json(indent=INDENT_4_SPACE_INT)}
"""

    @staticmethod
    def from_json_resp(resp_str: str) -> List["Clock"]:
        try:
            response = remove_code_formatting(resp_str)
            clock_dict = JsonOutputParser(pydantic_object=Clock).parse(response)
            if isinstance(clock_dict, dict):
                clock_dict = [clock_dict]
            return [Clock(**item) for item in clock_dict]
        except Exception as e:
            print(f"cannot generate clock port list: {e}")
            return []


class Reset(BaseModel):
    name: str
    type: str

    @staticmethod
    def module_reset_template() -> str:
        return f"""
"format": 
{Reset(
    name = "Name of reset signal", type = "type of reset signal(e.g. wire, logic)"
).model_dump_json(indent=INDENT_4_SPACE_INT)}
"""

    @staticmethod
    def from_json_resp(resp_str: str) -> List["Reset"]:
        try:
            response = remove_code_formatting(resp_str)
            reset_dict = JsonOutputParser(pydantic_object=Reset).parse(response)
            if isinstance(reset_dict, dict):
                reset_dict = [reset_dict]
            return [Reset(**item) for item in reset_dict]
        except Exception as e:
            print(f"cannot generate reset port list: {e}")
            return []


class Module(JSONValidatedBaseModel):
    """
    Represents a module in a SystemVerilog file.
    """

    model_config = ConfigDict(alias_generator=to_camel, populate_by_name=True)

    name: str
    parameters: List[ModuleParameter] = []
    input_ports: List[ModulePort]
    inout_ports: List[ModulePort] = []
    output_ports: List[ModulePort]
    interfaces: List[ModuleInterface] = []
    clock_ports: List[Clock] = []
    reset_ports: List[Reset] = []
    instance: str = ""
    type_aliases: Dict[str, str] = {}
    internal_signals: List[str] = []

    def __init__(
        self,
        name: str,
        parameters: List[ModuleParameter] = [],
        input_ports: List[ModulePort] = [],
        inout_ports: List[ModulePort] = [],
        output_ports: List[ModulePort] = [],
        interfaces: List[ModuleInterface] = [],
        clock_ports: List[Clock] = [],
        reset_ports: List[Reset] = [],
        instance: str = "",
        type_aliases: Dict[str, str] = {},
        internal_signals: List[str] = [],
        **kwargs,
    ):
        super().__init__(
            name=name,
            parameters=parameters,
            input_ports=input_ports,
            inout_ports=inout_ports,
            output_ports=output_ports,
            interfaces=interfaces,
            instance=instance,
            clock_ports=clock_ports,
            reset_ports=reset_ports,
            type_aliases=type_aliases,
            internal_signals=internal_signals,
            **kwargs,
        )

    def model_post_init(self, __context):
        self.input_ports, new_clock_ports = self.filter_out_clock_ports(
            self.input_ports
        )
        self.input_ports, new_reset_ports = self.filter_out_reset_ports(
            self.input_ports
        )
        self.clock_ports.extend(new_clock_ports)
        self.reset_ports.extend(new_reset_ports)

    def get_port_by_name(self, port_name: str) -> Optional[ModulePort]:
        """
        Gets a port by name.

        Args:
            port_name (str): The name of the port.

        Returns:
            Optional[ModulePort]: The port with the given name.
        """
        for port in self.input_ports + self.inout_ports + self.output_ports:
            if port.name == port_name:
                return port

        return None

    def get_parameter_by_name(self, parameter_name: str) -> Optional[ModuleParameter]:
        """
        Gets a parameter by name.

        Args:
            parameter_name (str): The name of the parameter.

        Returns:
            Optional[ModuleParameter]: The parameter with the given name.
        """
        for parameter in self.parameters:
            if parameter.name == parameter_name:
                return parameter

        return None

    def filter_out_clock_ports(
        self, input_ports: List[ModulePort]
    ) -> Tuple[List[ModulePort], List[Clock]]:
        clocks: List[Clock] = []
        inputs: List[ModulePort] = []

        for input_port in input_ports:
            if "clk" in input_port.name.lower() or "clock" in input_port.name.lower():
                clocks.append(Clock(name=input_port.name, type=input_port.type))
            else:
                inputs.append(input_port)

        return inputs, clocks

    def filter_out_reset_ports(
        self, input_ports: List[ModulePort]
    ) -> Tuple[List[ModulePort], List[Reset]]:
        resets: List[Reset] = []
        inputs: List[ModulePort] = []

        for input_port in input_ports:
            if "rst" in input_port.name.lower() or "reset" in input_port.name.lower():
                resets.append(Reset(name=input_port.name, type=input_port.type))
            else:
                inputs.append(input_port)

        return inputs, resets


class ScenarioDetail(BaseModel):
    name: str
    description: str
    category: str = ""
    type: str = "Assertion"
    metadata: dict = {}
