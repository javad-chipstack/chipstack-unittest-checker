import re
from typing import List, Any, Union
from chipstack_common.svutils.sv_parse_types import (
    Module,
    ModuleInterface,
    ModulePort,
    Clock,
    Reset,
    INDENT_4_SPACE,
    INDENT_8_SPACE,
)
import chipstack_common.svutils.regex as regex_patterns
from chipstack_common.svutils.sv_parser import get_module_interface
from chipstack_common.string_handlers.llm_response import (
    remove_code_formatting,
)
from chipstack_common.string_handlers.strings import (
    indent_multiline_string,
    unindent_multiline_string,
    generate_valid_identifier,
    is_whole_word_in_string,
)
from chipstack_common.svutils.regex import TYPE_ALIAS_ID_REGEX

MONITOR_NAME_SUFFIX = "_monitor"
LOGIC_TYPE = "logic"


def convert_module_to_monitor(module: Module, monitor_name: str) -> Module:
    monitor = Module(
        name=monitor_name,
        input_ports=module.input_ports + module.inout_ports + module.output_ports,
        clock_ports=module.clock_ports,
        reset_ports=module.reset_ports,
        interfaces=[
            ModuleInterface(
                name=interface.name,
                instance=interface.instance,
                modport=interface.modport,
                input_ports=interface.input_ports + interface.output_ports,
                output_ports=[],
            )
            for interface in module.interfaces
        ],
        parameters=module.parameters,
    )

    for interface in monitor.interfaces:
        for interface_port in interface.input_ports:
            interface_port.type = re.sub(
                regex_patterns.REG_OR_WIRE_REGEX, LOGIC_TYPE, interface_port.type
            )

    for port in monitor.input_ports + monitor.clock_ports + monitor.reset_ports:
        port.type = re.sub(regex_patterns.REG_OR_WIRE_REGEX, LOGIC_TYPE, port.type)
    return monitor


def generate_submodule_model(name: str, code: str, dut_top_module: Module) -> Module:
    # Remove single and multiline verilog comments
    code = re.sub(regex_patterns.COMMENT_PATTERN, "", code)
    # Split by word boundaries
    words = re.split(r"\b", code)
    # Filter out non-word characters (e.g. punctuation, symbols, etc.)
    # and words that start with a digit
    words = [
        word for word in words if re.match(r"\w+", word) and not re.match(r"^\d", word)
    ]
    # Trim whitespace and filter out empty strings
    ports_and_params = [word.strip() for word in words if word.strip() != ""]
    # Remove duplicates and sort names
    ports_and_params = sorted(list(set(ports_and_params)))

    # Filter ports and interfaces
    def get_intersection(
        subset_names: List[str],
        all_items: List[Any],
    ):
        return [item for item in all_items if item.name in subset_names]

    return Module(
        name=name,
        input_ports=get_intersection(ports_and_params, dut_top_module.input_ports),
        clock_ports=get_intersection(ports_and_params, dut_top_module.clock_ports),
        reset_ports=get_intersection(ports_and_params, dut_top_module.reset_ports),
        inout_ports=get_intersection(ports_and_params, dut_top_module.inout_ports),
        output_ports=get_intersection(ports_and_params, dut_top_module.output_ports),
        interfaces=(
            get_intersection(ports_and_params, dut_top_module.interfaces)
            if dut_top_module.interfaces
            else []
        ),
        parameters=dut_top_module.parameters,
        instance="",  # skip instantiation here
    )


def generate_bind_interface_signals(module: Module) -> List[str]:
    bind_monitor_interface_signals: List[str] = []
    if not module.interfaces:
        return bind_monitor_interface_signals
    for interface_inst in module.interfaces:
        for port in interface_inst.input_ports + interface_inst.output_ports:
            signal_line = (
                f".{interface_inst.name}_{port.name}({interface_inst.name}.{port.name})"
            )
            bind_monitor_interface_signals.append(signal_line)
    return bind_monitor_interface_signals


def get_interface_signal_name(interface: ModuleInterface, port: ModulePort) -> str:
    return f"{interface.name}_{port.name}"


def generate_interface_signals(module: Module) -> List[str]:
    """
    Generate interface signals as ports.
    """
    if not module.interfaces:
        return []
    ports = []
    for interface_inst in module.interfaces:
        ports += [
            f"input {port.type} {get_interface_signal_name(interface_inst, port)}"
            for port in interface_inst.input_ports
        ]
        ports += [
            f"output {port.type} {get_interface_signal_name(interface_inst, port)}"
            for port in interface_inst.output_ports
        ]
    return ports


def generate_interface_signals_as_internal(module: Module) -> List[str]:
    """
    Generate interface signals as internal signals.
    """
    if not module.interfaces:
        return []
    ports = []
    for interface_inst in module.interfaces:
        ports += [
            f"{port.type} {get_interface_signal_name(interface_inst, port)}"
            for port in interface_inst.input_ports
        ]
        ports += [
            f"{port.type} {get_interface_signal_name(interface_inst, port)}"
            for port in interface_inst.output_ports
        ]
    return ports


def unpack_packed_signals(port: Union[ModulePort, Clock, Reset]) -> str:
    """
    Slang packs unpacked signals. E.g. `input logic [3:0] a[2:0]` is packed as `input logic [3:0]$[2:0]`.
    We want to unpack this to `input logic [3:0] a[2:0]`.
    """
    packed_types = port.type.split("$")
    if len(packed_types) == 1:
        return f"{port.type} {port.name}"
    return f"{packed_types[0]} {port.name}{packed_types[1]}"


def generate_module_declaration(parsed_module: Module, invert_ports_dir=False) -> str:
    """
    Generate module declaration with all ports and parameters.
    """
    module_declaration = f"module {parsed_module.name}"

    if parsed_module.parameters:
        parameters = ",\n".join(
            f"{INDENT_8_SPACE}parameter {param.type} {param.name} = {param.value}"
            for param in parsed_module.parameters
        )
        module_declaration += f"\n{INDENT_4_SPACE}#(\n{parameters}\n{INDENT_4_SPACE})"

    ports = [
        f"input {unpack_packed_signals(port)}"
        for port in parsed_module.clock_ports + parsed_module.reset_ports
    ]
    if invert_ports_dir:
        ports += [
            f"output {unpack_packed_signals(port)}"
            for port in parsed_module.input_ports
        ]
        ports += [
            f"input {unpack_packed_signals(port)}"
            for port in parsed_module.output_ports
        ]
    else:
        ports += [
            f"input {unpack_packed_signals(port)}" for port in parsed_module.input_ports
        ]
        ports += [
            f"output {unpack_packed_signals(port)}"
            for port in parsed_module.output_ports
        ]

    ports += [
        f"inout {unpack_packed_signals(port)}" for port in parsed_module.inout_ports
    ]
    ports += generate_interface_signals(parsed_module)

    if ports:
        ports_declaration = ",\n".join(f"{INDENT_8_SPACE}{port}" for port in ports)
        module_declaration += (
            f"\n{INDENT_4_SPACE}(\n{ports_declaration}\n{INDENT_4_SPACE});\n"
        )
    else:
        module_declaration += ";\n"

    return module_declaration


def generate_module_declaration_no_ports(parsed_module: Module) -> str:
    """
    Generate module declaration with empty port list and all ports are converted to module's internal signals.
    """
    module_declaration = f"module {parsed_module.name}"

    if parsed_module.parameters:
        parameters = ",\n".join(
            f"{INDENT_8_SPACE}parameter {param.type} {param.name} = {param.value}"
            for param in parsed_module.parameters
        )
        module_declaration += f"\n{INDENT_4_SPACE}#(\n{parameters}\n{INDENT_4_SPACE})"
    module_declaration += " ();\n"

    ports = [
        f"{unpack_packed_signals(port)}"
        for port in parsed_module.clock_ports + parsed_module.reset_ports
    ]
    ports += [f"{unpack_packed_signals(port)}" for port in parsed_module.input_ports]
    ports += [f"{unpack_packed_signals(port)}" for port in parsed_module.output_ports]

    ports += [f"{unpack_packed_signals(port)}" for port in parsed_module.inout_ports]
    ports += generate_interface_signals_as_internal(parsed_module)

    if ports:
        ports_declaration = ";\n".join(f"{INDENT_4_SPACE}{port}" for port in ports)
        module_declaration += f"\n{ports_declaration};\n\n"
    else:
        module_declaration += "\n"

    return module_declaration


def generate_instantiation_statement(
    module: Module, top_module_name: str, instance_name: str
) -> str:
    instantiation_parameters = [
        f"{INDENT_4_SPACE}.{param.name}({param.name})" for param in module.parameters
    ]
    joined_instantiation_parameters = ",\n".join(instantiation_parameters)
    instantiation_parameters_string = (
        f"\n#(\n{joined_instantiation_parameters}\n) "
        if instantiation_parameters
        else ""
    )

    instantiation_ports_list = [
        f"{INDENT_4_SPACE}.{port.name}({port.name})"
        for port in module.clock_ports
        + module.reset_ports
        + module.input_ports
        + module.inout_ports
        + module.output_ports
    ]
    instantiation_interface_ports = generate_bind_interface_signals(module)
    instantiation_ports_list += instantiation_interface_ports
    instantiation_ports = ",\n".join(instantiation_ports_list)

    result = f"""{
        top_module_name
    } {
        instantiation_parameters_string
    } {
        instance_name
    } (\n{
        instantiation_ports
    }\n);\n"""

    result = indent_multiline_string(result, exclude_first_line=True)
    return result


def generate_monitor_module_bind_statement(module: Module, monitor: Module) -> str:
    instance_statement = generate_instantiation_statement(
        module, f"{monitor.name}", "monitor"
    )
    bind = f"bind {module.name} {instance_statement}"
    return bind


def get_formal_unit_test_template(module: Module) -> dict[str, str]:
    monitor_module = convert_module_to_monitor(
        module, monitor_name=module.name + MONITOR_NAME_SUFFIX
    )

    monitor = generate_module_declaration(monitor_module)
    bind = generate_monitor_module_bind_statement(module, monitor=monitor_module)

    return {
        "monitor": monitor,
        "bind": bind,
    }


def generate_dummy_module_initialization(module: Module) -> str:
    dummyModule = ""
    if len(module.output_ports) > 0:
        for port in module.output_ports:
            dummyModule += f"{INDENT_4_SPACE}assign {port.name} = 0;\n"
        dummyModule += "\n"
    return dummyModule


def generate_dummy_module_code(module: Module) -> str:
    module_dec = generate_module_declaration(module)
    module_content = generate_dummy_module_initialization(module)
    return f"{module_dec}\n{module_content}endmodule\n"


def remove_module_declaration_and_endmodule(code: str) -> str:
    module_declaration = get_module_interface(code)
    while module_declaration:
        code = code.replace(module_declaration, "")
        module_declaration = get_module_interface(code)
    code = code.replace("endmodule", "")
    return code


def remove_includes(code: str) -> str:
    return re.sub(regex_patterns.INCLUDES_REGEX, "", code)


def extract_task_code(code: str) -> str:
    lines = code.split("\n")
    task_begin_line = -1
    task_end_line = -1
    for i, line in enumerate(lines):
        task_start = re.search(regex_patterns.TASK_START_REGEX, line)
        task_end = re.search(regex_patterns.TASK_END_REGEX, line)

        if task_start:
            task_begin_line = i
        if task_end:
            task_end_line = i
            break
    task_code = "\n".join(lines[task_begin_line : task_end_line + 1])
    return task_code


def generate_entire_module(
    codeblock: str,
    module_name: str,
    dut_parsed_model: Module,
    ports_as_internal_signals: bool = False,
) -> str:

    sanitized_module_name = generate_valid_identifier(module_name)

    module_body = remove_module_declaration_and_endmodule(codeblock)
    parsed_module = generate_submodule_model(
        name=sanitized_module_name,
        code=remove_code_formatting(module_body),
        dut_top_module=dut_parsed_model,
    )
    if ports_as_internal_signals:
        module_declaration = generate_module_declaration_no_ports(parsed_module)
    else:
        module_declaration = generate_module_declaration(
            parsed_module, invert_ports_dir=True
        )
    module_code = f"""{
        module_declaration
    }{
        indent_multiline_string(unindent_multiline_string(module_body))
    }
    endmodule"""

    return module_code


def get_task_body(task_code: str) -> str:
    result = re.sub(
        regex_patterns.TASK_DECLARATION_REGEX, "", task_code, flags=re.MULTILINE
    )

    match = re.search(
        regex_patterns.ENDTASK_REGEX,
        result,
        flags=re.MULTILINE | re.IGNORECASE | re.DOTALL,
    )
    if match:
        first_endtask_index = match.start()
        return result[:first_endtask_index]

    return result


def add_type_aliases_to_module(
    dut_parsed_model: Module, codeblocks: List[str]
) -> List[str]:
    type_aliases_keys = list(dut_parsed_model.type_aliases.keys())
    updated_codeblocks = []
    for task in codeblocks:
        type_aliases_keys_in_task = []
        for type_alias in type_aliases_keys:
            if is_whole_word_in_string(type_alias, task):
                type_aliases_keys_in_task.append(type_alias)

        type_alias_definitions = []
        if type_aliases_keys_in_task:
            for type_alias in type_aliases_keys_in_task:
                type_alias_definitions.append(
                    "typedef "
                    + re.sub(
                        TYPE_ALIAS_ID_REGEX,
                        f" {type_alias};",
                        dut_parsed_model.type_aliases[type_alias],
                    )
                )
            type_alias_definitions_str = "\n".join(type_alias_definitions)
            updated_codeblocks.append(f"{type_alias_definitions_str}\n{task}")
        else:
            updated_codeblocks.append(task)
    return updated_codeblocks
